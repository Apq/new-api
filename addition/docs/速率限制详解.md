# 速率限制详解

## 一、概述

本系统实现了四种速率限制机制，用于保护系统资源、防止滥用：

| 限制类型 | 作用范围 | 限制对象 | 主要用途 |
|---------|---------|---------|---------|
| 全局速率限制 | Web/API 接口 | IP 地址 | 防止 DDoS、爬虫攻击 |
| 模型请求速率限制 | AI 模型调用 | 用户 ID | 控制 API 调用频率 |
| 邮件验证速率限制 | 邮件发送 | IP 地址 | 防止邮件轰炸 |
| 通知速率限制 | 通知发送 | 用户 ID + 通知类型 | 防止通知轰炸 |

## 二、核心文件

| 文件路径 | 功能描述 |
|---------|---------|
| `middleware/rate-limit.go` | 全局速率限制中间件 |
| `middleware/model-rate-limit.go` | 模型请求速率限制中间件 |
| `middleware/email-verification-rate-limit.go` | 邮件验证速率限制中间件 |
| `service/notify-limit.go` | 通知速率限制服务 |
| `common/rate-limit.go` | 内存限流器实现 |
| `common/limiter/limiter.go` | Redis 令牌桶限流器 |
| `common/limiter/lua/rate_limit.lua` | 令牌桶 Lua 脚本 |
| `setting/rate_limit.go` | 模型限流配置管理 |
| `common/constants.go` | 限流常量定义 |

## 三、全局速率限制

### 3.1 限制类型

系统提供五种全局速率限制（**默认均为禁用状态**）：

| 限制名称 | 标识 | 默认启用 | 默认配置 | 应用场景 |
|---------|------|---------|---------|---------|
| GlobalWebRateLimit | GW | 否 | 300次/60秒 | Web 页面请求 |
| GlobalAPIRateLimit | GA | 否 | 600次/60秒 | API 接口请求 |
| CriticalRateLimit | CT | 否 | 60次/10分钟 | 关键操作（登录、注册等） |
| DownloadRateLimit | DW | 否 | 30次/60秒 | 文件下载 |
| UploadRateLimit | UP | 否 | 30次/60秒 | 文件上传 |

### 3.2 配置参数

**环境变量配置** (`common/init.go`):

```bash
# Web 限流（默认禁用）
GLOBAL_WEB_RATE_LIMIT_ENABLE=false   # 是否启用
GLOBAL_WEB_RATE_LIMIT=300            # 最大请求数
GLOBAL_WEB_RATE_LIMIT_DURATION=60    # 时间窗口（秒）

# API 限流（默认禁用）
GLOBAL_API_RATE_LIMIT_ENABLE=false
GLOBAL_API_RATE_LIMIT=600
GLOBAL_API_RATE_LIMIT_DURATION=60

# 关键操作限流（默认禁用）
CRITICAL_RATE_LIMIT_ENABLE=false
CRITICAL_RATE_LIMIT=60
CRITICAL_RATE_LIMIT_DURATION=600     # 10分钟

# 上传限流（默认禁用）
UPLOAD_RATE_LIMIT_ENABLE=false
UPLOAD_RATE_LIMIT=30
UPLOAD_RATE_LIMIT_DURATION=60

# 下载限流（默认禁用）
DOWNLOAD_RATE_LIMIT_ENABLE=false
DOWNLOAD_RATE_LIMIT=30
DOWNLOAD_RATE_LIMIT_DURATION=60
```

### 3.3 实现原理

#### 滑动窗口算法

全局限流采用**滑动窗口**算法，使用 Redis List 或内存队列存储请求时间戳：

```
请求队列: [t1, t2, t3, ..., tn]  (按时间排序，新请求在左侧)
```

**判断逻辑**:
1. 如果队列长度 < 最大请求数，允许请求
2. 如果队列长度 >= 最大请求数，检查最老请求时间
   - 如果 (当前时间 - 最老时间) >= 时间窗口，移除最老请求，允许新请求
   - 否则拒绝请求

#### Redis 实现 (`middleware/rate-limit.go`)

```go
func redisRateLimiter(c *gin.Context, maxRequestNum int, duration int64, mark string) {
    ctx := context.Background()
    rdb := common.RDB
    key := "rateLimit:" + mark + c.ClientIP()  // 按 IP 限流

    // 获取队列长度
    listLength, _ := rdb.LLen(ctx, key).Result()

    if listLength < int64(maxRequestNum) {
        // 未达到限制，记录请求时间
        rdb.LPush(ctx, key, time.Now().Format(timeFormat))
        rdb.Expire(ctx, key, common.RateLimitKeyExpirationDuration)
    } else {
        // 检查时间窗口
        oldTimeStr, _ := rdb.LIndex(ctx, key, -1).Result()
        oldTime, _ := time.Parse(timeFormat, oldTimeStr)
        nowTime := time.Now()

        if int64(nowTime.Sub(oldTime).Seconds()) < duration {
            // 在时间窗口内，拒绝请求
            c.Status(http.StatusTooManyRequests)
            c.Abort()
            return
        } else {
            // 超出时间窗口，移除旧记录，添加新记录
            rdb.LPush(ctx, key, time.Now().Format(timeFormat))
            rdb.LTrim(ctx, key, 0, int64(maxRequestNum-1))
            rdb.Expire(ctx, key, common.RateLimitKeyExpirationDuration)
        }
    }
}
```

#### 内存实现 (`common/rate-limit.go`)

```go
type InMemoryRateLimiter struct {
    store              map[string]*[]int64  // key -> 时间戳队列
    mutex              sync.Mutex
    expirationDuration time.Duration
}

func (l *InMemoryRateLimiter) Request(key string, maxRequestNum int, duration int64) bool {
    l.mutex.Lock()
    defer l.mutex.Unlock()

    queue, ok := l.store[key]
    now := time.Now().Unix()

    if ok {
        if len(*queue) < maxRequestNum {
            // 未达到限制
            *queue = append(*queue, now)
            return true
        } else {
            // 检查时间窗口
            if now - (*queue)[0] >= duration {
                // 移除最老记录，添加新记录
                *queue = (*queue)[1:]
                *queue = append(*queue, now)
                return true
            } else {
                return false  // 拒绝
            }
        }
    } else {
        // 首次请求
        s := make([]int64, 0, maxRequestNum)
        l.store[key] = &s
        *(l.store[key]) = append(*(l.store[key]), now)
    }
    return true
}
```

### 3.4 流程图

```
请求进入
    ↓
获取客户端 IP
    ↓
生成限流 Key: "rateLimit:{mark}{IP}"
    ↓
检查是否启用 Redis
    ├─ 是 → Redis 限流器
    └─ 否 → 内存限流器
           ↓
    获取请求队列长度
           ↓
    队列长度 < 最大请求数?
    ├─ 是 → 记录请求时间 → 放行
    └─ 否 → 检查最老请求时间
              ↓
         (当前时间 - 最老时间) >= 时间窗口?
         ├─ 是 → 移除旧记录 → 记录新请求 → 放行
         └─ 否 → 返回 429 Too Many Requests
```

### 3.5 路由应用

**Web 路由** (`router/web-router.go`):
```go
webRouter.Use(middleware.GlobalWebRateLimit())
```

**API 路由** (`router/api-router.go`):
```go
apiRouter.Use(middleware.GlobalAPIRateLimit())
```

**关键操作** (`router/api-router.go`):
```go
userRoute.POST("/register", middleware.CriticalRateLimit(), controller.Register)
userRoute.POST("/login", middleware.CriticalRateLimit(), controller.Login)
```

---

## 四、模型请求速率限制

### 4.1 限制类型

模型请求限流支持两种计数方式：

| 计数类型 | 说明 | 默认值 |
|---------|------|-------|
| 总请求数限制 | 包括成功和失败的所有请求 | 0（不限制） |
| 成功请求数限制 | 仅计算成功的请求（HTTP < 400） | 1000次/分钟 |

### 4.2 配置参数

> **配置位置**: 管理后台 → 系统设置 → 速率限制设置
>
> **重要**: 模型请求速率限制**不支持环境变量配置**，只能在管理后台运行时配置，配置保存在数据库 `options` 表中。

#### 管理后台配置字段

| 界面字段 | 代码变量 | 说明 |
|---------|---------|------|
| 启用用户模型请求速率限制 | `ModelRequestRateLimitEnabled` | 总开关 |
| 限制周期 | `ModelRequestRateLimitDurationMinutes` | 时间窗口（分钟） |
| 用户每周期最多请求次数 | `ModelRequestRateLimitCount` | 总请求数限制，0=不限制 |
| 用户每周期最多请求完成次数 | `ModelRequestRateLimitSuccessCount` | 成功请求数限制 |
| 分组速率限制 | `ModelRequestRateLimitGroup` | JSON 格式的分组配置 |

#### 代码默认值 (`setting/rate_limit.go`)

```go
var ModelRequestRateLimitEnabled = false           // 是否启用
var ModelRequestRateLimitDurationMinutes = 1       // 时间窗口（分钟）
var ModelRequestRateLimitCount = 0                 // 总请求数限制（0=不限制）
var ModelRequestRateLimitSuccessCount = 1000       // 成功请求数限制
```

#### 分组配置 JSON 格式

```json
{
    "分组名": [总请求数, 成功请求数]
}
```

**示例**:
```json
{
    "admin":   [0, 999999],    // admin 分组：不限制总请求，成功请求最多 999999 次
    "default": [255, 245],     // default 分组：总请求最多 255 次，成功请求最多 245 次
    "vip":     [500, 480],     // vip 分组：总请求最多 500 次，成功请求最多 480 次
    "svip":    [620, 600]      // svip 分组：总请求最多 620 次，成功请求最多 600 次
}
```

**说明**:
- 第一个值（总请求数）为 0 时表示不限制总请求数
- 分组配置优先级高于全局配置
- 限制周期统一使用全局的"限制周期"值

### 4.3 实现原理

模型请求限流根据存储方式采用不同策略：

| 存储方式 | 成功请求数限制 | 总请求数限制 |
|---------|--------------|-------------|
| Redis | 滑动窗口 | **令牌桶** |
| 内存 | 滑动窗口 | 滑动窗口 |

**注意**: 令牌桶算法**仅在 Redis 模式下**用于总请求数限制。内存模式下两种限制都使用滑动窗口算法。

#### 令牌桶算法

令牌桶是一种流量整形算法，核心思想：
- 桶以固定速率生成令牌
- 每个请求消耗一定数量的令牌
- 桶有最大容量，超出的令牌被丢弃
- 令牌不足时拒绝请求

**Lua 脚本实现** (`common/limiter/lua/rate_limit.lua`):

```lua
-- 参数
local key = KEYS[1]           -- 限流器标识
local requested = ARGV[1]     -- 请求令牌数
local rate = ARGV[2]          -- 令牌生成速率（每秒）
local capacity = ARGV[3]      -- 桶容量

-- 获取当前时间
local now = redis.call('TIME')
local nowInSeconds = tonumber(now[1])

-- 获取桶状态
local bucket = redis.call('HMGET', key, 'tokens', 'last_time')
local tokens = tonumber(bucket[1])
local last_time = tonumber(bucket[2])

-- 初始化或计算新增令牌
if not tokens or not last_time then
    tokens = capacity
    last_time = nowInSeconds
else
    local elapsed = nowInSeconds - last_time
    local add_tokens = elapsed * rate
    tokens = math.min(capacity, tokens + add_tokens)
    last_time = nowInSeconds
end

-- 判断是否允许请求
local allowed = false
if tokens >= requested then
    tokens = tokens - requested
    allowed = true
end

-- 更新桶状态
redis.call('HMSET', key, 'tokens', tokens, 'last_time', last_time)

return allowed and 1 or 0
```

#### Redis 限流处理器 (`middleware/model-rate-limit.go`)

```go
func redisRateLimitHandler(duration int64, totalMaxCount, successMaxCount int) gin.HandlerFunc {
    return func(c *gin.Context) {
        userId := strconv.Itoa(c.GetInt("id"))
        ctx := context.Background()
        rdb := common.RDB

        // 1. 检查成功请求数限制（滑动窗口）
        successKey := fmt.Sprintf("rateLimit:%s:%s", ModelRequestRateLimitSuccessCountMark, userId)
        allowed, _ := checkRedisRateLimit(ctx, rdb, successKey, successMaxCount, duration)
        if !allowed {
            abortWithOpenAiMessage(c, http.StatusTooManyRequests,
                fmt.Sprintf("您已达到请求数限制：%d分钟内最多请求%d次",
                    setting.ModelRequestRateLimitDurationMinutes, successMaxCount))
            return
        }

        // 2. 检查总请求数限制（令牌桶）
        if totalMaxCount > 0 {
            totalKey := fmt.Sprintf("rateLimit:%s", userId)
            tb := limiter.New(ctx, rdb)
            allowed, _ = tb.Allow(ctx, totalKey,
                limiter.WithCapacity(int64(totalMaxCount) * duration),
                limiter.WithRate(int64(totalMaxCount)),
                limiter.WithRequested(duration),
            )
            if !allowed {
                abortWithOpenAiMessage(c, http.StatusTooManyRequests,
                    fmt.Sprintf("您已达到总请求数限制：%d分钟内最多请求%d次，包括失败次数",
                        setting.ModelRequestRateLimitDurationMinutes, totalMaxCount))
                return
            }
        }

        // 3. 处理请求
        c.Next()

        // 4. 请求成功后记录
        if c.Writer.Status() < 400 {
            recordRedisRequest(ctx, rdb, successKey, successMaxCount)
        }
    }
}
```

### 4.4 流程图

```
请求进入
    ↓
检查是否启用模型限流 (ModelRequestRateLimitEnabled)
    ├─ 否 → 直接放行
    └─ 是 ↓
获取用户 ID 和分组
    ↓
获取分组限流配置（优先使用分组配置，否则使用全局配置）
    ↓
选择限流器
    ├─ Redis 模式 ────────────────────────────────────────┐
    │   ↓                                                 │
    │   1. 检查成功请求数限制（滑动窗口）                    │
    │      Key: "rateLimit:MRRLS:{userId}"                │
    │      超限 → 返回 429                                 │
    │   ↓                                                 │
    │   2. 检查总请求数限制（令牌桶，仅当 > 0 时）           │
    │      Key: "rateLimit:{userId}"                      │
    │      超限 → 返回 429                                 │
    │   ↓                                                 │
    │   调用上游 API                                       │
    │   ↓                                                 │
    │   响应状态码 < 400? → 记录成功请求                    │
    │                                                     │
    └─ 内存模式 ──────────────────────────────────────────┐
        ↓                                                 │
        1. 检查总请求数限制（滑动窗口，仅当 > 0 时）         │
           Key: "MRRL{userId}"                            │
           超限 → 返回 429                                 │
        ↓                                                 │
        2. 检查成功请求数限制（滑动窗口）                    │
           Key: "MRRLS{userId}_check"                     │
           超限 → 返回 429                                 │
        ↓                                                 │
        调用上游 API                                       │
        ↓                                                 │
        响应状态码 < 400? → 记录成功请求到 "MRRLS{userId}"  │
```

**Redis 与内存模式的差异**:
- Redis 模式：先检查成功请求数，再检查总请求数（令牌桶）
- 内存模式：先检查总请求数，再检查成功请求数（都是滑动窗口）

### 4.5 令牌桶参数计算

```go
// 配置示例：1分钟内最多 60 次请求
totalMaxCount := 60
duration := 60  // 秒

// 令牌桶参数
capacity := totalMaxCount * duration  // 桶容量 = 3600
rate := totalMaxCount                 // 生成速率 = 60 令牌/秒
requested := duration                 // 每次请求消耗 = 60 令牌
```

**效果**：
- 桶容量 3600，每秒生成 60 个令牌
- 每次请求消耗 60 个令牌
- 平均每秒最多 1 次请求，但允许突发

---

## 五、邮件验证速率限制

### 5.1 配置参数

```go
const (
    EmailVerificationRateLimitMark = "EV"
    EmailVerificationMaxRequests   = 2   // 30秒内最多2次
    EmailVerificationDuration      = 30  // 30秒时间窗口
)
```

### 5.2 实现原理

邮件验证限流采用**计数器 + 过期时间**的简单策略：

#### Redis 实现

```go
func redisEmailVerificationRateLimiter(c *gin.Context) {
    ctx := context.Background()
    rdb := common.RDB
    key := "emailVerification:" + EmailVerificationRateLimitMark + ":" + c.ClientIP()

    // 原子递增计数
    count, _ := rdb.Incr(ctx, key).Result()

    // 首次设置过期时间
    if count == 1 {
        rdb.Expire(ctx, key, time.Duration(EmailVerificationDuration)*time.Second)
    }

    // 检查是否超限
    if count <= int64(EmailVerificationMaxRequests) {
        c.Next()
        return
    }

    // 获取剩余等待时间
    ttl, _ := rdb.TTL(ctx, key).Result()
    waitSeconds := int64(ttl.Seconds())

    c.JSON(http.StatusTooManyRequests, gin.H{
        "success": false,
        "message": fmt.Sprintf("发送过于频繁，请等待 %d 秒后再试", waitSeconds),
    })
    c.Abort()
}
```

#### 内存实现

```go
func memoryEmailVerificationRateLimiter(c *gin.Context) {
    key := EmailVerificationRateLimitMark + ":" + c.ClientIP()

    if !inMemoryRateLimiter.Request(key, EmailVerificationMaxRequests, EmailVerificationDuration) {
        c.JSON(http.StatusTooManyRequests, gin.H{
            "success": false,
            "message": "发送过于频繁，请稍后再试",
        })
        c.Abort()
        return
    }

    c.Next()
}
```

### 5.3 流程图

```
邮件发送请求
    ↓
获取客户端 IP
    ↓
生成限流 Key: "emailVerification:EV:{IP}"
    ↓
检查是否启用 Redis
    ├─ 是 → Redis 计数器
    │       ↓
    │   INCR key（原子递增）
    │       ↓
    │   首次请求? → 设置 30 秒过期
    │       ↓
    │   count <= 2?
    │   ├─ 是 → 放行
    │   └─ 否 → 获取 TTL → 返回等待时间
    │
    └─ 否 → 内存限流器（滑动窗口）
            ↓
        Request(key, 2, 30)
            ↓
        允许?
        ├─ 是 → 放行
        └─ 否 → 返回 429
```

---

## 六、通知速率限制

### 6.1 功能说明

通知速率限制用于控制系统向用户发送通知（如余额不足提醒、配额告警等）的频率，防止通知轰炸。

### 6.2 配置参数

**环境变量配置** (`common/init.go`):

```bash
NOTIFY_LIMIT_COUNT=2                      # 限制次数，默认 2 次
NOTIFICATION_LIMIT_DURATION_MINUTE=10     # 时间窗口（分钟），默认 10 分钟
```

| 参数 | 环境变量 | 默认值 | 说明 |
|-----|---------|-------|------|
| 限制次数 | `NOTIFY_LIMIT_COUNT` | 2 | 时间窗口内最多发送次数 |
| 时间窗口 | `NOTIFICATION_LIMIT_DURATION_MINUTE` | 10 | 限制周期（分钟） |

### 6.3 实现原理

通知限流采用**计数器 + 时间窗口**策略，按用户 ID + 通知类型 + 小时进行限流：

#### Redis 实现

```go
func checkRedisLimit(userId int, notifyType string) (bool, error) {
    // Key 格式：notify_limit:{userId}:{notifyType}:{hour}
    key := fmt.Sprintf("notify_limit:%d:%s:%s", userId, notifyType, time.Now().Format("2006010215"))

    // 获取当前计数
    count, err := common.RedisGet(key)
    if count == "" {
        // 首次请求，初始化计数
        err = common.RedisSet(key, "1", getDuration())
        return true, err
    }

    currentCount, _ := strconv.Atoi(count)
    limit := constant.NotifyLimitCount

    // 检查是否超限
    if currentCount >= limit {
        return false, nil
    }

    // 递增计数
    err = common.RedisIncr(key, 1)
    return true, err
}
```

#### 内存实现

```go
func checkMemoryLimit(userId int, notifyType string) (bool, error) {
    key := fmt.Sprintf("%d:%s:%s", userId, notifyType, time.Now().Format("2006010215"))

    // 获取或初始化计数
    var currentLimit limitCount
    if value, ok := notifyLimitStore.Load(key); ok {
        currentLimit = value.(limitCount)
        // 检查是否过期
        if now.Sub(currentLimit.Timestamp) >= getDuration() {
            currentLimit = limitCount{Count: 0, Timestamp: now}
        }
    }

    // 递增并检查
    currentLimit.Count++
    notifyLimitStore.Store(key, currentLimit)

    return currentLimit.Count <= limit, nil
}
```

### 6.4 流程图

```
通知发送请求
    ↓
获取用户 ID 和通知类型
    ↓
生成限流 Key: "notify_limit:{userId}:{type}:{hour}"
    ↓
检查是否启用 Redis
    ├─ 是 → Redis 计数器
    │       ↓
    │   获取当前计数
    │       ↓
    │   count >= limit?
    │   ├─ 是 → 拒绝发送
    │   └─ 否 → 递增计数 → 允许发送
    │
    └─ 否 → 内存计数器
            ↓
        获取或初始化计数
            ↓
        检查是否过期 → 过期则重置
            ↓
        递增计数
            ↓
        count <= limit?
        ├─ 是 → 允许发送
        └─ 否 → 拒绝发送
```

### 6.5 使用方式

```go
// 检查是否可以发送通知
allowed, err := service.CheckNotificationLimit(userId, "balance_warning")
if !allowed {
    // 超过限制，不发送通知
    return
}
// 发送通知...
```

---

## 七、存储方式对比

### 7.1 Redis vs 内存

| 特性 | Redis | 内存 |
|-----|-------|------|
| 分布式支持 | ✅ 多实例共享 | ❌ 单实例 |
| 持久化 | ✅ 重启不丢失 | ❌ 重启清空 |
| 性能 | 网络开销 | 本地访问快 |
| 适用场景 | 生产环境 | 开发/单机 |

### 7.2 自动选择逻辑

```go
if common.RedisEnabled {
    // 使用 Redis 限流器
    redisRateLimiter(...)
} else {
    // 使用内存限流器
    inMemoryRateLimiter.Init(common.RateLimitKeyExpirationDuration)
    memoryRateLimiter(...)
}
```

---

## 八、限流算法对比

| 算法 | 优点 | 缺点 | 使用场景 |
|-----|------|------|---------|
| 滑动窗口 | 精确控制、平滑限流 | 存储开销大 | 全局限流、成功请求限流、内存模式总请求限流 |
| 令牌桶 | 允许突发、平滑输出 | 实现复杂、仅 Redis 支持 | Redis 模式下的总请求数限流 |
| 计数器 | 实现简单 | 边界问题 | 邮件验证限流、通知限流 |

---

## 九、错误响应

### 9.1 全局限流

```
HTTP 429 Too Many Requests
```

### 9.2 模型请求限流

```json
{
    "error": {
        "message": "您已达到请求数限制：1分钟内最多请求1000次",
        "type": "rate_limit_error",
        "code": "rate_limit_exceeded"
    }
}
```

### 9.3 邮件验证限流

```json
{
    "success": false,
    "message": "发送过于频繁，请等待 25 秒后再试"
}
```

---

## 十、Redis Key 命名规范

| 限流类型 | Key 格式 | 示例 |
|---------|---------|------|
| Web 限流 | `rateLimit:GW{IP}` | `rateLimit:GW192.168.1.1` |
| API 限流 | `rateLimit:GA{IP}` | `rateLimit:GA192.168.1.1` |
| 关键操作 | `rateLimit:CT{IP}` | `rateLimit:CT192.168.1.1` |
| 下载限流 | `rateLimit:DW{IP}` | `rateLimit:DW192.168.1.1` |
| 上传限流 | `rateLimit:UP{IP}` | `rateLimit:UP192.168.1.1` |
| 模型总请求 | `rateLimit:{userId}` | `rateLimit:123` |
| 模型成功请求 | `rateLimit:MRRLS:{userId}` | `rateLimit:MRRLS:123` |
| 邮件验证 | `emailVerification:EV:{IP}` | `emailVerification:EV:192.168.1.1` |
| 通知限流 | `notify_limit:{userId}:{type}:{hour}` | `notify_limit:123:balance_warning:2024010112` |

---

## 十一、配置建议

### 11.1 生产环境推荐配置

> **注意**: 五种全局速率限制默认均为禁用状态，如需启用请根据实际需求配置。

```bash
# 全局限流（按需启用，以下为严格配置示例）
GLOBAL_WEB_RATE_LIMIT_ENABLE=true
GLOBAL_WEB_RATE_LIMIT=100
GLOBAL_WEB_RATE_LIMIT_DURATION=60

GLOBAL_API_RATE_LIMIT_ENABLE=true
GLOBAL_API_RATE_LIMIT=300
GLOBAL_API_RATE_LIMIT_DURATION=60

CRITICAL_RATE_LIMIT_ENABLE=true
CRITICAL_RATE_LIMIT=30
CRITICAL_RATE_LIMIT_DURATION=600

UPLOAD_RATE_LIMIT_ENABLE=true
UPLOAD_RATE_LIMIT=20
UPLOAD_RATE_LIMIT_DURATION=60

DOWNLOAD_RATE_LIMIT_ENABLE=true
DOWNLOAD_RATE_LIMIT=20
DOWNLOAD_RATE_LIMIT_DURATION=60
```

### 11.2 模型限流推荐配置

> **配置位置**: 管理后台 → 系统设置 → 速率限制设置（详见第四章 4.2 节）

**推荐配置值**:

| 配置项 | 推荐值 |
|-------|-------|
| 启用用户模型请求速率限制 | true |
| 限制周期 | 1 分钟 |
| 用户每周期最多请求次数 | 0（不限制） |
| 用户每周期最多请求完成次数 | 60 |

**分组速率限制推荐配置**:

```json
{
    "default": [0, 60],
    "vip": [0, 120],
    "svip": [0, 300]
}
```

---

## 十二、总结

本系统的速率限制机制具有以下特点：

1. **多层防护**: 全局限流 + 模型限流 + 邮件限流 + 通知限流，层层保护
2. **灵活配置**: 支持环境变量和管理后台运行时配置
3. **分组支持**: 不同用户组可配置不同限流策略，分组配置优先级高于全局配置
4. **双存储**: 支持 Redis（分布式）和内存（单机）两种模式，自动选择
5. **多算法**:
   - 滑动窗口：用于全局限流、成功请求限流、内存模式总请求限流
   - 令牌桶：仅 Redis 模式下用于总请求数限流，支持突发流量
   - 计数器：用于邮件验证限流、通知限流
6. **友好提示**: 返回详细的错误信息和等待时间

### 模型请求限流配置速查

| 配置项 | 管理后台字段 | 说明 |
|-------|------------|------|
| 总开关 | 启用用户模型请求速率限制 | 关闭后所有模型限流不生效 |
| 时间窗口 | 限制周期 | 单位：分钟 |
| 总请求数 | 用户每周期最多请求次数 | 0=不限制，Redis 下使用令牌桶 |
| 成功请求数 | 用户每周期最多请求完成次数 | 使用滑动窗口算法 |
| 分组配置 | 分组速率限制 | JSON 格式：`{"组名": [总请求数, 成功请求数]}` |
