# 用户凭证重构方案

## 一、背景

当前系统中 `User.AccessToken` 字段被两个功能混用：

| 功能 | 入口 | 使用方式 |
|------|------|----------|
| **Web 登录** | `POST /api/user/login/access_token` | 请求体中传入 `access_token` |
| **API 调用** | 任何需要认证的 API | `Authorization` header 传入 |

**存在的问题**：
1. 无法区分用途：同一个 token 既能登录 Web 也能调用 API
2. 权限控制粗糙：无法对两种用途进行细粒度控制
3. 单一凭证：每个用户只能有一个凭证，无法满足多设备登录需求
4. 安全风险：token 泄露后攻击者可同时获得 Web 和 API 访问权限

## 二、重构目标

1. **分离职责**：`User.AccessToken` 专用于 API 调用，新建 `UserCredential` 表专用于 Web 登录
2. **支持多凭证**：一个用户可以拥有多个登录凭证
3. **性能优化**：有效凭证数据缓存，加速登录验证和 AI 请求处理

## 三、数据模型设计

### 3.1 新增 UserCredential 表

**文件**: `model/user_credential.go`

```go
type UserCredential struct {
    Id          int            `json:"id" gorm:"primaryKey"`
    UserId      int            `json:"user_id" gorm:"index;not null"`           // 关联用户
    Key         string         `json:"key" gorm:"type:char(32);uniqueIndex"`    // 凭证码
    Name        string         `json:"name" gorm:"type:varchar(64)"`            // 凭证名称
    Status      int            `json:"status" gorm:"default:1"`                 // 1-启用, 2-禁用
    CreatedAt   time.Time      `json:"created_at"`
    LastUsedAt  *time.Time     `json:"last_used_at"`                            // 最后使用时间
    ExpiredAt   *int64         `json:"expired_at"`                              // 过期时间，null永不过期
    DeletedAt   gorm.DeletedAt `json:"-" gorm:"index"`
}
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `Id` | int | 主键 |
| `UserId` | int | 关联用户ID，建立索引 |
| `Key` | char(32) | 凭证码，唯一索引 |
| `Name` | varchar(64) | 凭证名称，便于用户识别 |
| `Status` | int | 状态：1-启用，2-禁用 |
| `CreatedAt` | time | 创建时间 |
| `LastUsedAt` | time | 最后使用时间，用于安全审计 |
| `ExpiredAt` | int64 | 过期时间戳，null 表示永不过期 |
| `DeletedAt` | time | 软删除时间 |

### 3.2 常量定义

**文件**: `common/constants.go`

```go
const (
    UserCredentialStatusEnabled  = 1  // 启用
    UserCredentialStatusDisabled = 2  // 禁用
    UserCredentialMaxCount       = 10 // 每个用户最多凭证数量
)
```

### 3.3 凭证数量限制

每个用户最多可拥有 **10 个**凭证（可配置），超出限制时需先删除旧凭证才能创建新凭证。

### 3.4 保留 User.AccessToken

`User.AccessToken` 字段保持不变，继续用于 API 调用认证（`Authorization` header）。

## 四、缓存设计

### 4.1 设计原则

1. **懒加载**：不在系统启动时加载，用到时才加入缓存
2. **只缓存有效凭证**：只缓存状态为启用、未过期、未软删除的凭证
3. **按用户过期**：用户 10 分钟内无 AI 请求，该用户的所有凭证从缓存移除

### 4.2 缓存结构

```go
// 按凭证码索引：用于登录验证
var userCredentialCacheByKey sync.Map  // key -> *UserCredential

// 按用户ID索引：用于缓存管理（加载、过期清理）
var userCredentialCacheByUserId sync.Map  // userId -> []*UserCredential

// 用户活跃时间：用于过期判断
var userCredentialLastActive sync.Map  // userId -> time.Time
```

### 4.3 缓存使用场景

| 场景 | 说明 |
|------|------|
| **登录验证** | 高频操作，精确匹配 Key |
| **AI 请求** | 高频操作，刷新活跃时间 |

### 4.4 缓存加载时机

| 时机 | 操作 | 说明 |
|------|------|------|
| **登录验证** | 按 Key 查询 | 缓存未命中时查数据库，加载该凭证及其所属用户的所有有效凭证 |
| **AI 请求** | 按 UserId 查询 | 缓存未命中时查数据库，加载该用户的所有有效凭证；同时刷新活跃时间 |

### 4.5 缓存过期策略

```
┌─────────────────────────────────────────────────────────────┐
│                     缓存过期机制                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   用户发起 AI 请求                                           │
│         │                                                   │
│         ▼                                                   │
│   更新 userCredentialLastActive[userId] = now()             │
│                                                             │
│   ─────────────────────────────────────────────────────     │
│                                                             │
│   后台清理协程（每分钟执行一次）                               │
│         │                                                   │
│         ▼                                                   │
│   遍历 userCredentialLastActive                             │
│         │                                                   │
│         ▼                                                   │
│   now() - lastActive > 10分钟 ?                             │
│         │                                                   │
│    ┌────┴────┐                                              │
│    ▼         ▼                                              │
│   否        是                                               │
│   │         │                                               │
│   │         ▼                                               │
│   │    删除该用户的所有凭证缓存                                │
│   │    - 遍历 ByUserId[userId]，逐个从 ByKey 删除            │
│   │    - 删除 ByUserId[userId]                              │
│   │    - 删除 LastActive[userId]                            │
│   │                                                         │
│   └─────────────────────────────────────────────────────    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**过期时间**：10 分钟（可配置）

### 4.6 缓存更新策略

| 操作 | 缓存更新 |
|------|----------|
| `Insert` | 如果该用户已在缓存中，追加新凭证到 `ByKey` 和 `ByUserId` |
| `Update` | 如果凭证变为无效（禁用/过期），从缓存中移除；否则更新缓存中的数据 |
| `Delete` | 如果该凭证已在缓存中，从 `ByKey` 和 `ByUserId` 中移除 |

**注意**：增删改操作只更新已在缓存中的数据，不主动加载未缓存的用户。

### 4.7 核心函数

```go
// 验证凭证（优先查缓存，未命中则查数据库并加载用户所有有效凭证）
func ValidateUserCredential(key string) *UserCredential

// 加载用户所有有效凭证到缓存（内部函数）
func loadUserCredentialsToCache(userId int)

// 刷新用户活跃时间（AI 请求时调用，如果用户不在缓存中则先加载）
func RefreshUserCredentialActive(userId int)

// 启动缓存清理协程
func StartUserCredentialCacheCleaner()

// 缓存更新（增删改时调用）
func updateUserCredentialCache(credential *UserCredential, action string)
```

## 五、变更清单

### 5.1 Model 层

| 文件 | 变更内容 |
|------|----------|
| `model/user_credential.go` | **新增** - 凭证模型、CRUD、缓存逻辑、缓存清理协程 |
| `model/main.go` | 添加 `UserCredential` 到 `AutoMigrate`，调用 `StartUserCredentialCacheCleaner()` |
| `model/log.go` | 修改日志查询，凭证搜索改为查 `UserCredential` 表 |
| `common/constants.go` | 添加 `UserCredentialStatusEnabled`、`UserCredentialStatusDisabled` 常量 |

### 5.2 Controller 层

| 文件 | 变更内容 |
|------|----------|
| `controller/user.go` | 修改 `LoginByAccessToken`，改为查询 `UserCredential`；修改批量新增用户，自动创建 `UserCredential` 而非设置 `AccessToken` |
| `controller/user_credential.go` | **新增** - 凭证管理接口（增删改查） |

### 5.3 Relay 层

| 文件 | 变更内容 |
|------|----------|
| `relay/` 相关文件 | AI 请求处理中调用 `model.RefreshUserCredentialActive(userId)` |

### 5.4 Router 层

| 文件 | 变更内容 |
|------|----------|
| `router/api-router.go` | 添加凭证管理路由 |

### 5.5 前端

| 文件 | 变更内容 |
|------|----------|
| `web/src/components/` | 新增凭证管理组件 |
| `web/src/pages/` | 用户设置页面集成凭证管理 |

## 六、API 设计

### 6.1 用户自己管理凭证

| 方法 | 路径 | 说明 |
|------|------|------|
| `GET` | `/api/user/credentials` | 获取当前用户的凭证列表 |
| `POST` | `/api/user/credential` | 创建新凭证 |
| `PUT` | `/api/user/credential/{id}` | 更新凭证（名称、状态） |
| `DELETE` | `/api/user/credential/{id}` | 删除凭证 |

### 6.2 管理员管理用户凭证

| 方法 | 路径 | 说明 |
|------|------|------|
| `GET` | `/api/user/{userId}/credentials` | 获取指定用户的凭证列表 |
| `POST` | `/api/user/{userId}/credential` | 为指定用户创建凭证 |
| `DELETE` | `/api/user/credential/{id}/admin` | 管理员删除凭证 |

## 七、代码变更详情

### 7.1 登录验证变更

**文件**: `controller/user.go`

```go
// 修改前
func LoginByAccessToken(c *gin.Context) {
    user := model.ValidateAccessToken(accessToken)
    // ...
}

// 修改后
func LoginByAccessToken(c *gin.Context) {
    credential := model.ValidateUserCredential(accessToken)
    if credential == nil {
        // 凭证无效
        return
    }
    user, _ := model.GetUserById(credential.UserId, false)
    // 更新最后使用时间
    credential.UpdateLastUsedAt()
    // ...
}
```

### 7.2 日志查询变更

**文件**: `model/log.go`

```go
// 修改前（第231-238行）
if username != "" {
    var userIds []int
    DB.Model(&User{}).Where("username LIKE ? OR display_name LIKE ? OR access_token LIKE ?",
        "%"+username+"%", "%"+username+"%", "%"+username+"%").Pluck("id", &userIds)
    // ...
}

// 修改后
if username != "" {
    var userIds []int
    // 1. 查用户表（用户名、显示名称）
    DB.Model(&User{}).Where("username LIKE ? OR display_name LIKE ?",
        "%"+username+"%", "%"+username+"%").Pluck("id", &userIds)

    // 2. 查凭证表（凭证码）- 直接查数据库，不走缓存
    var credentialUserIds []int
    DB.Model(&UserCredential{}).Where("key LIKE ?", "%"+username+"%").
        Distinct().Pluck("user_id", &credentialUserIds)

    // 3. 合并去重
    userIds = mergeAndDeduplicateIds(userIds, credentialUserIds)
    // ...
}
```

### 7.3 缓存懒加载

**文件**: `model/user_credential.go`

```go
// 按 Key 查询凭证（登录验证时调用）
func ValidateUserCredential(key string) *UserCredential {
    // 1. 先查缓存
    if cached, ok := userCredentialCacheByKey.Load(key); ok {
        return cached.(*UserCredential)
    }

    // 2. 缓存未命中，查数据库（只查有效凭证）
    var credential UserCredential
    now := time.Now().Unix()
    if DB.Where("key = ? AND status = ? AND (expired_at IS NULL OR expired_at > ?)",
        key, common.UserCredentialStatusEnabled, now).First(&credential).RowsAffected == 0 {
        return nil
    }

    // 3. 加载该用户的所有有效凭证到缓存
    loadUserCredentialsToCache(credential.UserId)

    // 4. 从缓存中返回（保持引用一致性）
    if cached, ok := userCredentialCacheByKey.Load(key); ok {
        return cached.(*UserCredential)
    }
    return nil
}

// 加载用户所有有效凭证到缓存（内部函数）
func loadUserCredentialsToCache(userId int) {
    var credentials []*UserCredential
    now := time.Now().Unix()
    // 只查询有效凭证：启用、未过期、未软删除
    DB.Where("user_id = ? AND status = ? AND (expired_at IS NULL OR expired_at > ?)",
        userId, common.UserCredentialStatusEnabled, now).Find(&credentials)

    // 按 UserId 索引
    userCredentialCacheByUserId.Store(userId, credentials)

    // 按 Key 索引
    for _, c := range credentials {
        userCredentialCacheByKey.Store(c.Key, c)
    }

    // 设置活跃时间
    userCredentialLastActive.Store(userId, time.Now())
}
```

### 7.4 更新最后使用时间

**文件**: `model/user_credential.go`

```go
// 更新凭证最后使用时间（登录成功后调用）
func (c *UserCredential) UpdateLastUsedAt() {
    now := time.Now()
    c.LastUsedAt = &now
    DB.Model(c).Update("last_used_at", now)
}
```

### 7.5 AI 请求时刷新活跃时间

**文件**: `model/user_credential.go`

**调用位置**: 在 `relay/` 相关文件的 AI 请求处理中调用

```go
// 刷新用户凭证缓存活跃时间（AI 请求时调用）
func RefreshUserCredentialActive(userId int) {
    // 如果用户不在缓存中，先加载
    if _, ok := userCredentialCacheByUserId.Load(userId); !ok {
        loadUserCredentialsToCache(userId)
        return
    }
    // 刷新活跃时间
    userCredentialLastActive.Store(userId, time.Now())
}
```

### 7.6 批量新增用户变更

**文件**: `controller/user.go`

```go
// 修改前（第1133-1147行）
// 生成 access_token
accessToken := common.GetUUID()
user.SetAccessToken(accessToken)

// 修改后
// 创建用户后，为其创建默认凭证
credential := &model.UserCredential{
    UserId: user.Id,
    Key:    common.GetUUID(),
    Name:   "默认凭证",
    Status: common.UserCredentialStatusEnabled,
}
credential.Insert()
```

### 7.7 缓存清理协程

**文件**: `model/user_credential.go`

```go
// 启动缓存清理协程（在 main.go 中调用）
func StartUserCredentialCacheCleaner() {
    go func() {
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        for range ticker.C {
            cleanExpiredUserCredentialCache()
        }
    }()
}

// 清理过期的用户凭证缓存
func cleanExpiredUserCredentialCache() {
    now := time.Now()
    expireThreshold := 10 * time.Minute // 可配置

    userCredentialLastActive.Range(func(key, value interface{}) bool {
        userId := key.(int)
        lastActive := value.(time.Time)

        if now.Sub(lastActive) > expireThreshold {
            // 获取该用户的所有凭证，逐个从 ByKey 删除
            if credentials, ok := userCredentialCacheByUserId.Load(userId); ok {
                for _, c := range credentials.([]*UserCredential) {
                    userCredentialCacheByKey.Delete(c.Key)
                }
            }
            // 删除 ByUserId 和 LastActive
            userCredentialCacheByUserId.Delete(userId)
            userCredentialLastActive.Delete(userId)
        }
        return true
    })
}
```

## 八、数据迁移（可选）

如需将现有 `User.AccessToken` 迁移到新表：

```sql
-- 将现有 access_token 迁移到 user_credentials 表
INSERT INTO user_credentials (user_id, key, name, status, created_at)
SELECT id, access_token, '默认凭证', 1, NOW()
FROM users
WHERE access_token IS NOT NULL AND access_token != '';
```

**注意**：迁移后需要通知用户，原有的 `access_token` 将仅用于 API 调用，Web 登录需使用新凭证。

## 九、兼容性考虑

1. **API 调用不受影响**：`User.AccessToken` 继续用于 `Authorization` header 认证
2. **登录方式变更**：Web 登录改为使用 `UserCredential.Key`
3. **前端适配**：用户设置页面需新增凭证管理功能

## 十、测试要点

1. **登录验证**：使用新凭证登录成功/失败，验证禁用/过期/软删除凭证无法登录
2. **凭证管理**：创建、更新、删除凭证，验证用户可拥有多个凭证，验证数量限制
3. **缓存一致性**：凭证变更后缓存正确更新
4. **缓存过期**：用户 10 分钟无 AI 请求后，缓存正确清理
5. **缓存懒加载**：首次登录/AI 请求时正确加载缓存
6. **日志查询**：通过凭证码搜索用户日志
7. **批量新增用户**：批量创建用户时自动创建默认凭证
8. **API 调用**：`User.AccessToken` 仍可用于 API 认证（不受影响）
9. **性能测试**：高并发下缓存命中率和响应时间
