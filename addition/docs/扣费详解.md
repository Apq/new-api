# 用户额度扣除详解

## 一、概述

本系统采用**预扣费 + 实际结算**的机制，支持多种 AI 模型（OpenAI、Claude、Gemini、Midjourney 等）的调用计费。

**重要说明**：只有**计量类型用户**（user_type=0）才会进行额度扣除，其他用户类型（周卡、月卡、季卡、半年卡、年卡、永久）不扣除额度。

### 用户类型定义

| 类型值 | 类型名称 | 是否扣费 |
|-------|---------|---------|
| 0 | 计量 | 是 |
| 1 | 周卡 | 否 |
| 2 | 月卡 | 否 |
| 3 | 季卡 | 否 |
| 4 | 半年卡 | 否 |
| 5 | 年卡 | 否 |
| 6 | 永久 | 否 |

## 二、核心扣费文件

| 文件路径 | 功能描述 |
|---------|---------|
| `service/quota.go` | 核心扣费逻辑，包含各类消费计算函数 |
| `service/pre_consume_quota.go` | 预扣费逻辑 |
| `relay/helper/price.go` | 价格计算辅助函数 |
| `model/user.go` | 用户额度增减数据库操作 |
| `model/token.go` | 令牌额度增减数据库操作 |
| `relay/compatible_handler.go` | 文本请求扣费处理 |
| `setting/ratio_setting/model_ratio.go` | 模型倍率配置 |
| `setting/ratio_setting/group_ratio.go` | 分组倍率配置 |

## 三、会触发扣除额度的操作

### 1. 文本对话 (Chat Completion)
- **文件**: `relay/compatible_handler.go`
- **函数**: `TextHelper()` -> `postConsumeQuota()`
- **触发条件**: 调用 `/v1/chat/completions` 等文本生成接口

### 2. 图像生成 (Image Generation)
- **文件**: `relay/image_handler.go`
- **函数**: `ImageHelper()` -> `postConsumeQuota()`
- **触发条件**: 调用 DALL-E、Midjourney 等图像生成接口

### 3. 音频处理 (Audio)
- **文件**: `relay/audio_handler.go`
- **函数**: `AudioHelper()` -> `postConsumeQuota()` 或 `PostAudioConsumeQuota()`
- **触发条件**: 调用 TTS、Whisper 等音频接口

### 4. 嵌入向量 (Embedding)
- **文件**: `relay/embedding_handler.go`
- **函数**: `EmbeddingHelper()` -> `postConsumeQuota()`
- **触发条件**: 调用文本嵌入接口

### 5. 重排序 (Rerank)
- **文件**: `relay/rerank_handler.go`
- **函数**: `RerankHelper()` -> `postConsumeQuota()`
- **触发条件**: 调用 Cohere 等重排序接口

### 6. Midjourney 绘图
- **文件**: `relay/mjproxy_handler.go`
- **函数**: `RelayMidjourneySubmit()` -> `PostConsumeQuota()`
- **触发条件**: 提交 Midjourney 任务（imagine、variation、upscale 等）

### 7. 视频/任务类 (Task)
- **文件**: `relay/relay_task.go`
- **函数**: `RelayTaskSubmit()` -> `PostConsumeQuota()`
- **触发条件**: 提交 Suno 音乐、视频生成等任务

### 8. WebSocket 实时对话
- **文件**: `service/quota.go`
- **函数**: `PreWssConsumeQuota()`, `PostWssConsumeQuota()`
- **触发条件**: 使用 GPT-4o Realtime 等实时对话接口

### 9. Claude 特殊处理
- **文件**: `service/quota.go`
- **函数**: `PostClaudeConsumeQuota()`
- **触发条件**: Claude 模型调用，支持缓存计费

## 四、扣除计算公式/算法

### 1. 基于 Token 的计费（按量计费）

**核心公式** (位于 `relay/compatible_handler.go`):

```
quota = (promptTokens - cachedTokens - imageTokens - audioTokens
         + cachedTokens * cacheRatio
         + imageTokens * imageRatio
         + cachedCreationTokens * cacheCreationRatio
         + completionTokens * completionRatio)
        * modelRatio * groupRatio
```

**各参数说明**:
| 参数 | 说明 |
|------|------|
| `promptTokens` | 输入 token 数 |
| `completionTokens` | 输出 token 数 |
| `modelRatio` | 模型倍率（定义在 `setting/ratio_setting/model_ratio.go`） |
| `groupRatio` | 分组倍率（定义在 `setting/ratio_setting/group_ratio.go`） |
| `completionRatio` | 补全倍率（输出相对输入的价格比例） |
| `cacheRatio` | 缓存读取倍率（通常 0.1-0.5） |
| `cacheCreationRatio` | 缓存创建倍率（Claude 专用，通常 1.25） |
| `imageRatio` | 图像 token 倍率 |
| `audioRatio` | 音频 token 倍率 |

### 2. 基于价格的计费（按次计费）

**公式** (位于 `relay/compatible_handler.go`):

```
quota = modelPrice * QuotaPerUnit * groupRatio
```

**其中**:
- `QuotaPerUnit = 500 * 1000.0` (定义在 `common/constants.go`)
- 即 $0.002 = 1 quota，$1 = 500,000 quota

### 3. 音频模型计费

**公式** (位于 `service/quota.go`):

```go
quota = (inputTextTokens
         + outputTextTokens * completionRatio
         + inputAudioTokens * audioRatio
         + outputAudioTokens * audioRatio * audioCompletionRatio)
        * modelRatio * groupRatio
```

### 4. Midjourney/任务类计费

**公式** (位于 `relay/relay_task.go`):

```go
ratio = modelPrice * groupRatio
// 如果有额外参数（如视频时长、尺寸）
for _, ra := range otherRatios {
    ratio *= ra
}
quota = int(ratio * QuotaPerUnit)
```

### 5. 预扣费计算

**公式** (位于 `relay/helper/price.go`):

```go
// 按量计费
preConsumedTokens = max(promptTokens, PreConsumedQuota) + maxTokens
preConsumedQuota = preConsumedTokens * modelRatio * groupRatio

// 按次计费
preConsumedQuota = modelPrice * QuotaPerUnit * groupRatio
```

## 五、关键数据库操作函数

### 用户额度操作 (`model/user.go`)

| 函数名 | 功能 |
|-------|------|
| `DecreaseUserQuota()` | 扣除用户额度 |
| `IncreaseUserQuota()` | 增加用户额度 |
| `GetUserQuota()` | 获取用户额度 |
| `UpdateUserUsedQuotaAndRequestCount()` | 更新已用额度和请求次数 |

### 令牌额度操作 (`model/token.go`)

| 函数名 | 功能 |
|-------|------|
| `DecreaseTokenQuota()` | 扣除令牌额度 |
| `IncreaseTokenQuota()` | 增加令牌额度 |

## 六、扣费流程

### 完整扣费流程图

```
1. 请求进入
      ↓
2. 检查用户类型 (GetUserType)
   - 如果是计量类型（user_type=0）：继续扣费流程
   - 如果是其他类型：跳过扣费，直接调用 API
      ↓
3. 预扣费检查 (PreConsumeQuota) [仅计量类型]
   - 检查用户额度是否充足
   - 检查令牌额度是否充足
   - 执行预扣费（如果额度不充足则跳过预扣费）
      ↓
4. 调用上游 API
      ↓
5. 获取实际使用量 (usage)
      ↓
6. 计算实际消费额度
      ↓
7. 结算差额 (PostConsumeQuota) [仅计量类型]
   - quotaDelta = 实际消费 - 预扣费
   - 如果 quotaDelta > 0: 补扣
   - 如果 quotaDelta < 0: 返还
      ↓
8. 记录消费日志 (RecordConsumeLog)
      ↓
9. 更新统计数据
   - UpdateUserUsedQuotaAndRequestCount
   - UpdateChannelUsedQuota
```

### 预扣费逻辑 (`service/pre_consume_quota.go`)

```go
func PreConsumeQuota(c *gin.Context, preConsumedQuota int, relayInfo *relaycommon.RelayInfo) {
    // 1. 检查用户类型，只有计量类型（UserTypeNormal=0）才需要扣费
    userType, err := model.GetUserType(relayInfo.UserId)
    if userType != common.UserTypeNormal {
        // 非计量类型用户，不需要预扣费
        relayInfo.FinalPreConsumedQuota = 0
        return nil
    }

    // 2. 获取用户额度
    userQuota := model.GetUserQuota(relayInfo.UserId, false)

    // 3. 检查额度是否充足
    if userQuota <= 0 {
        return error("用户额度不足")
    }

    // 4. 信任额度机制（额度充足时跳过预扣费）
    trustQuota := common.GetTrustQuota() // 10 * QuotaPerUnit = $10
    if userQuota > trustQuota {
        preConsumedQuota = 0  // 不需要预扣费
    }

    // 5. 执行预扣费
    if preConsumedQuota > 0 {
        model.DecreaseTokenQuota(...)
        model.DecreaseUserQuota(...)
    }
}
```

### 实际扣费逻辑 (`service/quota.go`)

```go
func PostConsumeQuota(relayInfo, quota, preConsumedQuota int, sendEmail bool) {
    // 1. 检查用户类型，只有计量类型（UserTypeNormal=0）才需要扣费
    userType, err := model.GetUserType(relayInfo.UserId)
    if userType != common.UserTypeNormal {
        // 非计量类型用户，不需要扣费
        return nil
    }

    // 2. 执行扣费或返还
    if quota > 0 {
        model.DecreaseUserQuota(relayInfo.UserId, quota)
    } else {
        model.IncreaseUserQuota(relayInfo.UserId, -quota, false)  // 返还
    }

    if !relayInfo.IsPlayground {
        if quota > 0 {
            model.DecreaseTokenQuota(...)
        } else {
            model.IncreaseTokenQuota(...)  // 返还
        }
    }

    // 3. 发送额度不足提醒
    if sendEmail {
        checkAndSendQuotaNotify(...)
    }
}
```

## 七、模型倍率配置示例

**文件**: `setting/ratio_setting/model_ratio.go`

```go
// 模型倍率
var defaultModelRatio = map[string]float64{
    "gpt-4":                  15,      // $30/1M tokens
    "gpt-4o":                 1.25,    // $2.5/1M tokens
    "gpt-4o-mini":            0.075,   // $0.15/1M tokens
    "claude-3-5-sonnet":      1.5,     // $3/1M tokens
    "claude-3-opus":          7.5,     // $15/1M tokens
    "deepseek-chat":          0.135,   // $0.27/1M tokens
    ...
}

// 补全倍率
var defaultCompletionRatio = map[string]float64{
    "gpt-4-gizmo-*":  2,
    "gpt-4o-gizmo-*": 3,
    "gpt-4-all":      2,
    "gpt-image-1":    8,
}

// 按次计费价格
var defaultModelPrice = map[string]float64{
    "dall-e-3":      0.04,   // $0.04/次
    "mj_imagine":    0.1,    // $0.1/次
    "mj_upscale":    0.05,   // $0.05/次
    "suno_music":    0.1,    // $0.1/次
    ...
}
```

## 八、分组倍率配置

**文件**: `setting/ratio_setting/group_ratio.go`

```go
// 分组倍率
var groupRatio = map[string]float64{
    "default": 1,
    "vip":     1,
    "svip":    1,
}

// 用户组-使用组特殊倍率
var GroupGroupRatio = map[string]map[string]float64{
    "vip": {
        "edit_this": 0.9,  // VIP用户使用某分组享受9折
    },
}
```

## 九、额度单位换算

**定义位置**: `common/constants.go`

```go
var QuotaPerUnit = 500 * 1000.0  // $0.002 = 1 quota
```

**换算关系**:
| 金额 | 额度 |
|------|------|
| $0.000002 | 1 quota |
| $0.002 | 1,000 quota |
| $1 | 500,000 quota |

## 十、特殊计费场景

### 1. Web Search 工具计费

**位置**: `relay/compatible_handler.go`

```go
webSearchPrice = operation_setting.GetWebSearchPricePerThousand(modelName, searchContextSize)
webSearchQuota = webSearchPrice * callCount / 1000 * groupRatio * QuotaPerUnit
```

### 2. Claude 缓存计费

**位置**: `service/quota.go`

```go
// 缓存读取
calculateQuota += cacheTokens * cacheRatio  // 通常 0.1

// 缓存创建 (5分钟/1小时不同价格)
calculateQuota += cacheCreationTokens5m * cacheCreationRatio5m  // 通常 1.25
calculateQuota += cacheCreationTokens1h * cacheCreationRatio1h  // 通常 1.6
```

### 3. 免费模型处理

**位置**: `relay/helper/price.go`

```go
if !operation_setting.GetQuotaSetting().EnableFreeModelPreConsume {
    if groupRatio == 0 || modelRatio == 0 || modelPrice == 0 {
        preConsumedQuota = 0
        freeModel = true
    }
}
```

## 十一、性能优化

### 1. 批量更新机制

**启用方式**: 设置环境变量 `BATCH_UPDATE_ENABLED=true`

**相关文件**: `model/utils.go`

**优化内容**:
- 将高频的数据库更新操作聚合，定时批量执行
- 使用批量 SQL（CASE WHEN 语法）减少数据库连接数
- 支持内存限制，防止 OOM（默认每种类型最大 10000 条记录）

**批量更新类型**:
| 类型 | 说明 |
|------|------|
| `BatchUpdateTypeUserQuota` | 用户额度更新 |
| `BatchUpdateTypeTokenQuota` | 令牌额度更新 |
| `BatchUpdateTypeUsedQuota` | 已用额度更新 |
| `BatchUpdateTypeChannelUsedQuota` | 渠道已用额度更新 |
| `BatchUpdateTypeRequestCount` | 请求次数更新 |

### 2. 日志异步批量写入

**启用方式**: 设置环境变量 `LOG_BATCH_ENABLED=true`

**相关文件**: `model/log_batch.go`

**优化内容**:
- 消费日志异步写入，不阻塞主请求
- 批量插入数据库，减少 IO 操作
- 支持通道缓冲，高并发时自动降级为同步写入

### 3. 熔断器机制

**相关文件**: `common/circuit_breaker.go`

**设计目的**:
当数据库或 Redis 出现故障时，如果继续发送请求会导致：
1. 请求堆积，耗尽连接池
2. 响应时间急剧增加
3. 级联故障，影响整个系统

熔断器通过快速失败的方式，在故障期间拒绝请求，保护系统稳定性。

**熔断器状态流转**:

```
                    失败次数达到阈值
    ┌─────────────────────────────────────┐
    │                                     ▼
┌───────┐                            ┌────────┐
│Closed │                            │  Open  │
│(正常) │                            │(熔断)  │
└───────┘                            └────────┘
    ▲                                     │
    │         超时后进入半开状态           │
    │    ┌────────────────────────────────┘
    │    ▼
    │ ┌──────────┐
    │ │ HalfOpen │
    │ │ (半开)   │
    │ └──────────┘
    │    │
    └────┘
  连续成功达到阈值
```

**状态说明**:

| 状态 | 说明 | 行为 |
|------|------|------|
| `Closed` | 正常工作 | 允许所有请求通过，记录失败次数 |
| `Open` | 熔断状态 | 拒绝所有请求，等待超时 |
| `HalfOpen` | 半开状态 | 允许有限请求测试，成功则关闭，失败则重新打开 |

**熔断器配置**:

| 熔断器 | 失败阈值 | 熔断超时 | 半开最大请求数 |
|--------|----------|----------|----------------|
| 数据库 | 10 次 | 60 秒 | 5 次 |
| Redis | 5 次 | 30 秒 | 3 次 |

**核心代码逻辑**:

```go
// 检查是否允许请求通过
func (cb *CircuitBreaker) Allow() bool {
    switch cb.state {
    case CircuitBreakerClosed:
        return true  // 正常状态，允许通过
    case CircuitBreakerOpen:
        if time.Since(cb.lastFailure) > cb.timeout {
            cb.state = CircuitBreakerHalfOpen  // 超时后进入半开
            return true
        }
        return false  // 熔断中，拒绝请求
    case CircuitBreakerHalfOpen:
        if cb.halfOpenCount < cb.halfOpenMax {
            cb.halfOpenCount++
            return true  // 允许有限请求测试
        }
        return false
    }
}

// 记录失败
func (cb *CircuitBreaker) RecordFailure() {
    cb.failureCount++
    if cb.state == CircuitBreakerHalfOpen {
        cb.state = CircuitBreakerOpen  // 半开状态失败，重新熔断
    } else if cb.failureCount >= cb.threshold {
        cb.state = CircuitBreakerOpen  // 达到阈值，触发熔断
    }
}

// 记录成功
func (cb *CircuitBreaker) RecordSuccess() {
    if cb.state == CircuitBreakerHalfOpen {
        cb.successCount++
        if cb.successCount >= cb.halfOpenMax {
            cb.state = CircuitBreakerClosed  // 连续成功，恢复正常
            cb.failureCount = 0
        }
    }
}
```

**使用场景**:
- 批量更新前检查 `IsDBAvailable()`
- 日志批量写入前检查 `IsDBAvailable()`
- 缓存操作前检查 `IsRedisAvailable()`

### 4. 缓存一致性检查

**启用方式**: 默认启用，设置 `CACHE_CONSISTENCY_CHECK=false` 可禁用

**相关文件**: `model/cache_consistency.go`

**优化内容**:
- 定期检查 Redis 缓存与数据库的一致性
- 自动修复不一致的数据
- 检查间隔：5 分钟

### 5. 批量更新内存限制

**相关文件**: `model/utils.go`

**设计目的**:
批量更新机制将数据库写入操作缓存在内存中，定时批量执行。但在高并发场景下，如果不限制内存使用，可能导致：
1. 内存占用过高，触发 OOM
2. 批量更新数据量过大，单次写入耗时过长
3. 服务崩溃时丢失大量数据

**内存限制机制**:

```
┌─────────────────────────────────────────────────────────────┐
│                    批量更新内存管理                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │ UserQuota   │    │ TokenQuota  │    │ UsedQuota   │ ... │
│  │ Map[id]val  │    │ Map[id]val  │    │ Map[id]val  │     │
│  │ Count: 1500 │    │ Count: 800  │    │ Count: 2000 │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
│         │                  │                  │             │
│         └──────────────────┼──────────────────┘             │
│                            ▼                                │
│                   ┌─────────────────┐                       │
│                   │  内存监控协程    │                       │
│                   │  每秒检查一次    │                       │
│                   └─────────────────┘                       │
│                            │                                │
│              Count >= 10000 ?                               │
│                   │                                         │
│         ┌────────┴────────┐                                │
│         ▼                 ▼                                │
│    ┌─────────┐      ┌──────────┐                           │
│    │ 继续等待 │      │ 强制刷新 │                           │
│    └─────────┘      └──────────┘                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**核心配置**:

| 配置项 | 默认值 | 说明 |
|--------|--------|------|
| `batchUpdateMaxMemory` | 10000 | 每种类型最大缓存记录数 |
| `batchUpdateCounts` | - | 原子计数器，跟踪每种类型的记录数 |

**数据结构**:

```go
// 5种批量更新类型，每种独立的 map 和锁
var batchUpdateStores []map[int]int   // 存储待更新数据
var batchUpdateLocks []sync.Mutex     // 每种类型独立的锁
var batchUpdateCounts []int32         // 原子计数器

// 批量更新类型
const (
    BatchUpdateTypeUserQuota        // 用户额度
    BatchUpdateTypeTokenQuota       // 令牌额度
    BatchUpdateTypeUsedQuota        // 已用额度
    BatchUpdateTypeChannelUsedQuota // 渠道已用额度
    BatchUpdateTypeRequestCount     // 请求次数
)
```

**核心代码逻辑**:

```go
// 添加新记录时更新计数器
func addNewRecord(type_ int, id int, value int) {
    batchUpdateLocks[type_].Lock()
    defer batchUpdateLocks[type_].Unlock()

    if _, ok := batchUpdateStores[type_][id]; !ok {
        batchUpdateStores[type_][id] = value
        atomic.AddInt32(&batchUpdateCounts[type_], 1)  // 新记录，计数+1
    } else {
        batchUpdateStores[type_][id] += value  // 已存在，累加值
    }
}

// 内存监控协程
func checkMemoryAndFlush() {
    for i := 0; i < BatchUpdateTypeCount; i++ {
        count := atomic.LoadInt32(&batchUpdateCounts[i])
        if int(count) >= batchUpdateMaxMemory {
            // 达到内存限制，强制刷新
            batchUpdate()
            return
        }
    }
}

// 批量更新后重置计数器
func batchUpdate() {
    for i := 0; i < BatchUpdateTypeCount; i++ {
        batchUpdateLocks[i].Lock()
        store := batchUpdateStores[i]
        batchUpdateStores[i] = make(map[int]int)
        atomic.StoreInt32(&batchUpdateCounts[i], 0)  // 重置计数器
        batchUpdateLocks[i].Unlock()
        // ... 执行批量更新
    }
}
```

**失败重试机制**:

```go
// 批量更新失败时，将数据放回缓冲区
if err != nil {
    batchUpdateLocks[i].Lock()
    for k, v := range store {
        if _, ok := batchUpdateStores[i][k]; ok {
            batchUpdateStores[i][k] += v  // 已存在，累加
        } else {
            batchUpdateStores[i][k] = v
            atomic.AddInt32(&batchUpdateCounts[i], 1)  // 恢复计数
        }
    }
    batchUpdateLocks[i].Unlock()
}
```

**批量SQL优化**:

使用 `CASE WHEN` 语法，将多条更新合并为一条 SQL：

```sql
-- 原来：N 条 SQL
UPDATE users SET quota = quota + 100 WHERE id = 1;
UPDATE users SET quota = quota + 200 WHERE id = 2;
UPDATE users SET quota = quota + 300 WHERE id = 3;

-- 优化后：1 条 SQL
UPDATE users SET quota = quota + CASE id
    WHEN 1 THEN 100
    WHEN 2 THEN 200
    WHEN 3 THEN 300
END WHERE id IN (1, 2, 3);
```

### 6. 减少重复查询

**相关文件**: `relay/common/relay_info.go`, `service/quota.go`

**优化内容**:
- 在 `RelayInfo` 中缓存 `TokenRemainQuota`，避免预扣费时重复查询令牌额度
- 复用认证阶段获取的用户/令牌信息
- 减少数据库和 Redis 访问次数

### 7. 环境变量配置

| 环境变量 | 默认值 | 说明 |
|---------|--------|------|
| `BATCH_UPDATE_ENABLED` | `true` | 是否启用批量更新（设置 `false` 禁用） |
| `BATCH_UPDATE_INTERVAL` | `5` | 批量更新间隔（秒） |
| `LOG_BATCH_ENABLED` | `true` | 是否启用日志批量写入（设置 `false` 禁用） |
| `CACHE_CONSISTENCY_CHECK` | `true` | 是否启用缓存一致性检查（设置 `false` 禁用） |

## 十二、总结

该系统的额度扣除机制设计完善，主要特点：

1. **用户类型区分**: 只有计量类型用户（user_type=0）才扣费，其他类型用户（周卡、月卡等）不扣费
2. **双重保障**: 预扣费 + 实际结算，防止超额使用
3. **灵活计费**: 支持按量（Token）和按次两种计费方式
4. **多级倍率**: 模型倍率 × 分组倍率，支持精细化定价
5. **信任机制**: 高额度用户跳过预扣费，提升体验
6. **缓存优化**: Claude 等模型支持缓存计费，降低成本
7. **完整日志**: 每次消费都有详细记录，便于追溯
8. **性能优化**: 批量更新、异步日志、熔断器、缓存一致性检查等多重优化
