# 上下文压缩功能设计

## 1. 功能概述

上下文压缩功能旨在减少 LLM 对话请求中的输入 token 数量，通过将历史对话消息压缩成摘要的方式，降低 API 调用成本。

### 1.0 核心设计原则（确保不破坏现有功能）

**最重要的原则**：压缩功能是一个**可选的增强功能**，任何情况下都不能阻断或破坏现有的请求转发流程。

1. **默认禁用**：系统默认不启用压缩功能，需要管理员手动开启
2. **静默失败**：压缩过程中的任何错误都应该静默处理，回退到使用原始消息
3. **无侵入性**：压缩逻辑只修改 `request.Messages`，不影响其他请求参数
4. **兼容现有流程**：与现有的 Token 计算、计费、重试、渠道选择等机制完全兼容
5. **PassThrough 优先**：当启用 PassThrough 模式时，压缩功能自动跳过

### 1.1 适用场景

- 仅对 **LLM 模型**（ChatCompletions）生效
- 不影响其他模型类型（图像生成、嵌入、TTS、语音识别等）

### 1.2 核心机制

当对话消息的 token 总数超过设定阈值时，自动将较早的消息压缩成摘要，保留最近的消息原样发送。

```
原始请求: [system] + [msg1] + [msg2] + ... + [msgN]
                     ↓
触发条件: 总 token 数 > 阈值(8000)
                     ↓
压缩处理: 从最新消息向前保留，直到累计 token 达到保留阈值(2000)
          剩余的旧消息 → 调用摘要模型 → 生成摘要
                     ↓
最终请求: [system] + [摘要] + [保留的最近消息]
```

**重要原则**：消息是最小单位，不会将单条消息拆分。保留消息时以完整消息为单位。

---

## 2. 配置项设计

### 2.1 系统级配置（options 表）

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| ContextCompressionEnabled | bool | false | 全局开关，是否启用上下文压缩功能 |
| ContextCompressionThreshold | int | 8000 | 触发压缩的 token 数阈值 |
| ContextCompressionRetain | int | 2000 | 保留最近消息的 token 数（不参与压缩） |
| ContextCompressionModel | string | "" (空字符串) | 用于生成摘要的模型，空字符串表示使用用户当前请求的模型 |
| ContextCompressionPrompt | string | (见下文) | 系统默认摘要提示词 |
| ContextCompressionBillUser | bool | true | 摘要生成是否向用户计费 |

**参数约束**：
- `Threshold` 必须 > `Retain`（严格大于，不允许相等）
- `Threshold` 范围: 1000 ~ 128000
- `Retain` 范围: 500 ~ 32000
- 违反约束时应返回明确的错误信息，如 "触发阈值必须大于保留阈值"

**压缩逻辑**：
```
1. 计算所有消息的总 token 数（包括 system 消息）
2. 如果总 token 数 <= Threshold，不压缩
3. 分离 system 消息和对话消息（user/assistant/tool）
4. 从最后一条对话消息向前遍历，累计 token 数
5. 当累计 token 数 > Retain 时停止（保留完整消息，不拆分）
6. 剩余的旧对话消息送去生成摘要
7. 组装结果：[原 system 消息] + [摘要] + [保留的对话消息]
```

### 2.2 用户级配置（user_settings 表）

| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| context_compression_enabled | TINYINT(1) | 0 | 0=跟随系统，1=启用，2=禁用 |
| context_compression_threshold | INT | NULL | NULL=跟随系统 |
| context_compression_retain | INT | NULL | NULL=跟随系统 |
| context_compression_model | VARCHAR(255) | "" | 空字符串=使用当前请求的模型 |
| context_compression_prompt | TEXT | NULL | 用户补充提示词（追加到系统提示词之后），NULL或空表示无自定义 |

### 2.3 配置优先级

```
用户设置（非0/非NULL/非空） > 系统设置 > 代码硬编码默认值
```

---

## 3. 数据库设计

### 3.1 新建 user_settings 表

```sql
CREATE TABLE user_settings (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL UNIQUE,

    -- 上下文压缩设置
    context_compression_enabled TINYINT(1) DEFAULT 0 COMMENT '0=跟随系统，1=启用，2=禁用',
    context_compression_threshold INT DEFAULT NULL COMMENT 'NULL=跟随系统，触发压缩的token数',
    context_compression_retain INT DEFAULT NULL COMMENT 'NULL=跟随系统，保留的token数',
    context_compression_model VARCHAR(255) DEFAULT '' COMMENT '空=跟随系统',
    context_compression_prompt TEXT DEFAULT NULL COMMENT '用户补充提示词，NULL或空字符串表示无自定义',

    -- 预留其他用户设置字段

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
-- 注意：user_id 已有 UNIQUE 约束，无需额外索引
```

### 3.2 options 表新增配置项

```sql
INSERT INTO options (key, value) VALUES
('ContextCompressionEnabled', 'false'),
('ContextCompressionThreshold', '8000'),
('ContextCompressionRetain', '2000'),
('ContextCompressionModel', ''),
('ContextCompressionPrompt', '请将以下对话历史压缩成一段简洁的摘要，保留关键信息：\n1. 用户的主要问题和需求\n2. 重要的决策和结论\n3. 关键的代码、变量名、文件路径等技术细节\n4. 未完成的任务或待解决的问题\n\n摘要应该让后续对话能够理解之前的上下文，但不需要逐条复述。'),
('ContextCompressionBillUser', 'true');
```

---

## 4. 摘要提示词设计

### 4.1 系统默认提示词

```
请将以下对话历史压缩成一段简洁的摘要，保留关键信息：
1. 用户的主要问题和需求
2. 重要的决策和结论
3. 关键的代码、变量名、文件路径等技术细节
4. 未完成的任务或待解决的问题

摘要应该让后续对话能够理解之前的上下文，但不需要逐条复述。
```

### 4.2 提示词组合逻辑

```
最终提示词 = 系统默认提示词 + "\n\n" + 用户自定义提示词（如果有）
```

### 4.3 用户自定义提示词示例

用户可以添加额外的指令，例如：
- "请特别关注代码相关的讨论"
- "保留所有提到的人名和日期"
- "用英文生成摘要"
- "摘要控制在200字以内"

---

## 5. 处理流程

### 5.1 集成位置说明

**重要**：压缩功能应该集成在 `relay/compatible_handler.go` 的 `TextHelper()` 函数中。

**推荐集成位置**：在第 68 行 `info.ShouldIncludeUsage = includeUsage` 之后，第 70 行 `adaptor := GetAdaptor(info.ApiType)` 之前。

```go
// 在 TextHelper() 函数中，第 68 行之后添加压缩逻辑：

info.ShouldIncludeUsage = includeUsage

// === 上下文压缩处理 ===
// 注意：必须在 PassThrough 检查之前执行，因为 PassThrough 模式下请求体直接透传
// shouldCompress 函数内部会检查 PassThrough 设置，如果启用则跳过压缩
if shouldCompress(c, info, request) {
    compressedMessages, err := compressContext(request.Messages, getCompressionConfig(c, info))
    if err == nil {
        request.Messages = compressedMessages
        // 设置上下文标记，用于后续设置响应头
        c.Set("context_compressed", true)
    }
    // 如果压缩失败，继续使用原始消息，不阻断请求
}
// === 上下文压缩处理结束 ===

adaptor := GetAdaptor(info.ApiType)
// ... 后续代码
```

**注意事项**：
1. 压缩逻辑必须在 `request` 深拷贝之后执行（第 36 行之后）
2. 压缩逻辑必须在 `adaptor.ConvertOpenAIRequest()` 之前执行（第 87 行之前）
3. `shouldCompress()` 函数内部需要检查 `PassThroughRequestEnabled` 和 `PassThroughBodyEnabled`，如果启用则返回 false
4. 压缩功能在 PassThrough 模式下不生效，因为请求体会直接透传到上游，不经过消息处理
5. 压缩失败时应该静默回退，不阻断原始请求

### 5.2 请求处理流程

```
┌─────────────────────────────────────────────────────────────┐
│                      收到 ChatCompletions 请求               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              检查是否为 LLM 模型（RelayModeChatCompletions） │
└─────────────────────────────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    │ 否                │ 是
                    ▼                   ▼
              直接透传请求      ┌───────────────────┐
                              │ 获取用户压缩配置   │
                              └───────────────────┘
                                        │
                                        ▼
                              ┌───────────────────┐
                              │ 功能是否启用？     │
                              └───────────────────┘
                                        │
                              ┌─────────┴─────────┐
                              │ 否                │ 是
                              ▼                   ▼
                        直接透传请求      ┌───────────────────┐
                                        │ 计算总 token 数    │
                                        └───────────────────┘
                                                  │
                                                  ▼
                                        ┌───────────────────┐
                                        │ token > 阈值？    │
                                        └───────────────────┘
                                                  │
                                        ┌─────────┴─────────┐
                                        │ 否                │ 是
                                        ▼                   ▼
                                  直接透传请求      ┌───────────────────┐
                                                  │ 执行压缩处理       │
                                                  └───────────────────┘
                                                            │
                                                            ▼
                                                  ┌───────────────────┐
                                                  │ 发送压缩后的请求   │
                                                  └───────────────────┘
```

### 5.2 压缩处理详细流程

**注意**：以下函数假设调用前已完成以下检查：
1. 请求类型为 ChatCompletions（LLM 模型）
2. 用户压缩配置已获取并合并（用户设置 > 系统设置 > 默认值）
3. 压缩功能已启用（用户未禁用且系统已开启）

**重要**：以下代码使用项目现有的 `dto.Message` 结构，需要注意：
- `ToolCalls` 字段类型是 `json.RawMessage`，需要使用 `ParseToolCalls()` 方法解析
- `ToolCallId` 字段名是小写 `d`（不是 `ToolCallID`）
- `Content` 字段类型是 `any`，应使用 `StringContent()` 和 `ParseContent()` 方法处理

```go
// compressContext 压缩上下文消息
// 参数 messages 使用项目现有的 dto.Message 类型
func compressContext(messages []dto.Message, config CompressionConfig) ([]dto.Message, error) {
    // 0. 边界检查：空消息或只有 system 消息
    if len(messages) == 0 {
        return messages, nil
    }

    // 1. 分离 system messages 和对话消息
    systemMsgs, dialogMsgs := separateMessages(messages)

    // 如果没有对话消息（只有 system），不压缩
    if len(dialogMsgs) == 0 {
        return messages, nil
    }

    // 2. 计算总 token 数（包括 system messages）
    totalTokens := calculateTotalTokens(messages) // 所有消息
    if totalTokens <= config.Threshold {
        return messages, nil
    }

    // 3. 从后向前保留对话消息，直到累计 token 达到 Retain 阈值
    retainTokens := 0
    retainStartIndex := len(dialogMsgs)

    for i := len(dialogMsgs) - 1; i >= 0; i-- {
        msgTokens := calculateMessageTokens(dialogMsgs[i])
        if retainTokens + msgTokens > config.Retain {
            // 不拆分消息，停在这里
            retainStartIndex = i + 1
            break
        }
        retainTokens += msgTokens
        retainStartIndex = i
    }

    // 3.1 确保至少保留最后一条消息（即使超过 Retain 阈值）
    if retainStartIndex >= len(dialogMsgs) {
        retainStartIndex = len(dialogMsgs) - 1
    }

    // 3.2 调整分割点，确保 tool 消息配对完整性
    // 如果分割点处是 tool 消息，需要向前移动到对应的 assistant 消息之前
    retainStartIndex = adjustForToolPairing(dialogMsgs, retainStartIndex)

    // 4. 如果所有对话消息都在保留范围内，不压缩
    if retainStartIndex == 0 {
        return messages, nil
    }

    toCompress := dialogMsgs[:retainStartIndex]   // 需要压缩的对话消息（compressed_messages = len(toCompress)）
    toRetain := dialogMsgs[retainStartIndex:]     // 保留的对话消息（retained_messages = len(toRetain)）

    // 5. 如果没有消息需要压缩（只有一条消息且超过 Retain），不压缩
    if len(toCompress) == 0 {
        return messages, nil
    }

    // 6. 生成摘要
    summary, err := generateSummary(toCompress, config)
    if err != nil {
        // 失败时直接返回原始消息，不阻断请求
        return messages, nil
    }

    // 7. 组装新消息列表：[原system消息] + [摘要] + [保留的对话消息]
    result := []dto.Message{}
    result = append(result, systemMsgs...)  // 保留所有原始 system messages

    // 确定摘要消息的角色：与原始系统消息保持一致
    // 某些模型（如 o1、o3、gpt-5）使用 "developer" 角色
    summaryRole := "system"
    if len(systemMsgs) > 0 {
        summaryRole = systemMsgs[0].Role // 使用第一条系统消息的角色
    }

    result = append(result, dto.Message{
        Role:    summaryRole,
        // 添加 "[对话历史摘要]" 前缀，帮助模型理解这是压缩后的历史上下文
        // 而不是原始的系统指令
        Content: "[对话历史摘要]\n" + summary,
    })
    result = append(result, toRetain...)

    return result, nil
}

// separateMessages 分离开头的 system 消息和对话消息
// 注意：只提取开头连续的 system 消息，对话中间的 system 消息视为对话的一部分
// 重要：某些模型（如 o1、o3、gpt-5）使用 "developer" 角色而不是 "system"
// 需要同时检查这两种角色
func separateMessages(messages []dto.Message) (systemMsgs []dto.Message, dialogMsgs []dto.Message) {
    i := 0
    // 提取开头连续的 system/developer 消息
    // 注意：o1、o3、gpt-5 等模型使用 "developer" 角色
    for i < len(messages) && isSystemRole(messages[i].Role) {
        systemMsgs = append(systemMsgs, messages[i])
        i++
    }
    // 剩余的都是对话消息（可能包含中间的 system 消息）
    dialogMsgs = messages[i:]
    return
}

// isSystemRole 判断角色是否为系统角色
// 某些模型（如 o1、o3、gpt-5）使用 "developer" 角色而不是 "system"
func isSystemRole(role string) bool {
    return role == "system" || role == "developer"
}

// adjustForToolPairing 调整分割点以确保 tool 消息配对完整性
// 规则：
// 1. 如果分割点处是 tool 消息，向前移动到对应的 assistant（带 tool_calls）消息之前
// 2. 如果分割点处的 assistant 消息带有 tool_calls，检查后续的 tool 消息是否都在保留范围内
// 注意：ToolCalls 是 json.RawMessage 类型，需要用 len() > 0 判断是否存在
func adjustForToolPairing(dialogMsgs []dto.Message, startIndex int) int {
    if startIndex >= len(dialogMsgs) || startIndex <= 0 {
        return startIndex
    }

    // 情况1：分割点是 tool 消息，需要向前找到对应的 assistant
    if dialogMsgs[startIndex].Role == "tool" {
        for i := startIndex - 1; i >= 0; i-- {
            // ToolCalls 是 json.RawMessage，用 len() > 0 判断是否存在
            if dialogMsgs[i].Role == "assistant" && len(dialogMsgs[i].ToolCalls) > 0 {
                return i // 将 assistant 和所有后续 tool 消息都保留
            }
        }
        // 如果找不到对应的 assistant（孤立的 tool 消息），记录警告日志
        // 保持原分割点，让 tool 消息被保留（虽然不完整，但比丢失好）
        log.Printf("警告：tool 消息找不到对应的 assistant，保持原分割点")
    }

    // 情况2：分割点前一条是带 tool_calls 的 assistant，检查 tool 消息是否完整
    if startIndex > 0 {
        prevMsg := dialogMsgs[startIndex-1]
        // 使用 ParseToolCalls() 方法解析 ToolCalls
        toolCalls := prevMsg.ParseToolCalls()
        if prevMsg.Role == "assistant" && len(toolCalls) > 0 {
            // 检查保留区内是否有该 assistant 对应的 tool 消息
            expectedToolCount := len(toolCalls)
            actualToolCount := 0
            for i := startIndex; i < len(dialogMsgs) && dialogMsgs[i].Role == "tool"; i++ {
                actualToolCount++
            }
            // 如果 tool 消息不完整（部分在压缩区，部分在保留区），
            // 需要将 assistant 和所有 tool 消息都保留，向前移动分割点
            if actualToolCount > 0 && actualToolCount < expectedToolCount {
                // 将分割点移到 assistant 之前，使 assistant 和所有后续 tool 消息都被保留
                return startIndex - 1
            }
            // 如果 actualToolCount == 0，说明所有 tool 消息都在压缩区，assistant 也应该在压缩区，不需要调整
            // 如果 actualToolCount == expectedToolCount，说明 tool 消息完整，不需要调整
        }
    }

    return startIndex
}
```

### 5.3 Token 计算说明

```go
// calculateMessageTokens 计算单条消息的 token 数
// 使用项目现有的 dto.Message 结构
func calculateMessageTokens(msg dto.Message) int {
    // 使用 tiktoken 或类似库计算 token 数
    // 需要考虑：
    // 1. 文本内容的 token 数
    // 2. 多媒体内容（图片等）按固定值估算或跳过
    // 3. role 和其他元数据的 token 开销（约 4 tokens/message）
    // 4. ToolCalls 的 token 数（如果有）

    // 使用 StringContent() 方法获取文本内容
    tokens := countTokens(msg.StringContent())
    tokens += 4 // message overhead

    // 计算 ToolCalls 的 token 数（assistant 消息）
    // 使用 ParseToolCalls() 方法解析 json.RawMessage
    toolCalls := msg.ParseToolCalls()
    for _, tc := range toolCalls {
        tokens += countTokens(tc.Function.Name)
        tokens += countTokens(tc.Function.Arguments)
        tokens += 10 // tool call overhead (id, type 等)
    }

    // 计算 tool 消息的 ToolCallId token 数
    // 注意：字段名是 ToolCallId（小写 d），不是 ToolCallID
    if msg.Role == "tool" && msg.ToolCallId != "" {
        tokens += countTokens(msg.ToolCallId)
    }

    return tokens
}
```

### 5.4 摘要生成请求

```go
// generateSummary 生成对话摘要
// 使用项目现有的 dto 结构
func generateSummary(messages []dto.Message, config CompressionConfig) (string, error) {
    // 构建摘要请求
    prompt := config.SystemPrompt
    if config.UserPrompt != "" {
        prompt += "\n\n" + config.UserPrompt
    }

    // 将消息转换为文本
    conversationText := formatMessagesAsText(messages)

    // 使用项目现有的 dto.GeneralOpenAIRequest 结构
    summaryRequest := dto.GeneralOpenAIRequest{
        Model: config.Model,
        Messages: []dto.Message{
            {Role: "system", Content: prompt},
            {Role: "user", Content: conversationText},
        },
        MaxTokens:   1000, // 限制摘要长度，确保摘要不会比原始消息更长
        Temperature: 0.3,  // 使用较低温度确保摘要稳定一致
    }

    // 调用摘要模型，设置 30 秒超时
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // callModelWithContext 是需要实现的内部函数，返回 *dto.TextResponse 类型
    // 该函数应该：
    // 1. 使用内部渠道调用摘要模型（避免递归触发压缩）
    // 2. 支持超时控制
    // 3. 根据 ContextCompressionBillUser 配置决定是否计费给用户
    response, err := callModelWithContext(ctx, summaryRequest)
    if err != nil {
        // 超时或其他错误，记录日志后返回
        log.Printf("摘要生成失败: %v", err)
        return "", err
    }

    // 检查响应是否有效
    // 注意：Message.Content 是 any 类型，需要使用 StringContent() 方法获取字符串内容
    if len(response.Choices) == 0 || response.Choices[0].Message.StringContent() == "" {
        return "", fmt.Errorf("摘要模型返回空内容")
    }

    return response.Choices[0].Message.StringContent(), nil
}

// formatMessagesAsText 将消息列表转换为文本格式
// 使用项目现有的 dto.Message 结构和方法
// 输出示例：
// [user]: 你好，我想了解一下 Go 语言的并发模型
//
// [assistant]: Go 语言使用 goroutine 和 channel 来实现并发...
//
// [user]: 能给我一个具体的例子吗？
//
// [assistant]: [工具调用: 1 个]
//
// [tool]: [工具返回: call_abc123] package main...
//
func formatMessagesAsText(messages []dto.Message) string {
    var builder strings.Builder
    for _, msg := range messages {
        builder.WriteString(fmt.Sprintf("[%s]: ", msg.Role))

        // 处理 tool 消息（function calling 的结果）
        if msg.Role == "tool" {
            // 注意：字段名是 ToolCallId（小写 d）
            builder.WriteString(fmt.Sprintf("[工具返回: %s]", msg.ToolCallId))
            // 使用 StringContent() 方法获取内容
            content := msg.StringContent()
            if content != "" {
                builder.WriteString(" ")
                builder.WriteString(content)
            }
            builder.WriteString("\n\n")
            continue
        }

        // 处理文本和多模态内容
        // 使用 ParseContent() 方法解析内容，该方法会处理字符串和数组两种格式
        contents := msg.ParseContent()
        for _, content := range contents {
            switch content.Type {
            case dto.ContentTypeText:
                builder.WriteString(content.Text)
            case dto.ContentTypeImageURL:
                builder.WriteString("[此处有图片]")
            case dto.ContentTypeInputAudio:
                builder.WriteString("[此处有音频]")
            case dto.ContentTypeFile:
                builder.WriteString("[此处有文件]")
            case dto.ContentTypeVideoUrl:
                builder.WriteString("[此处有视频]")
            }
        }

        // 处理 assistant 消息中的 tool_calls
        // 使用 ParseToolCalls() 方法解析
        toolCalls := msg.ParseToolCalls()
        if len(toolCalls) > 0 {
            builder.WriteString(fmt.Sprintf(" [工具调用: %d 个]", len(toolCalls)))
        }

        builder.WriteString("\n\n")
    }
    return builder.String()
}
```

---

## 6. 特殊情况处理

### 6.1 System Message 处理

**基本原则**：
- 只保留**开头连续的** system message，不参与压缩
- 对话中间的 system message 视为对话的一部分，可能被压缩
- **重要**：某些模型（如 o1、o3、gpt-5）使用 `developer` 角色而不是 `system`，需要同时识别这两种角色

**Token 计算规则**：
- **阈值判断**：计算所有消息的 token 数（包括 system）
- **保留计算**：只计算对话消息（开头 system 之后的所有消息）的 token 数

**多个 system message 的处理**：
- 只保留开头连续的 system message，保持原有顺序
- 摘要作为新的 system message 插入到**开头 system 之后、对话消息之前**
- 对话中间的 system message 会被当作对话的一部分处理

**示例**：

```
原始: [sys1] + [sys2] + [user1] + [assistant1] + [user2] + [assistant2] + [user3]
压缩后: [sys1] + [sys2] + [摘要sys] + [user2] + [assistant2] + [user3]

特殊情况（中间有 system）:
原始: [sys1] + [user1] + [sys_mid] + [assistant1] + [user2]
压缩后: [sys1] + [摘要sys] + [user2]  （sys_mid 被压缩进摘要）
```

### 6.2 Tool 消息处理

- tool 消息（function calling 的结果）通常与前面的 assistant 消息配对
- 压缩时需要保持 assistant（带 tool_calls）和 tool 消息的配对关系
- 如果要压缩包含 tool 调用的消息，需要将整个调用链（assistant + tool）作为一个整体处理
- 摘要中应标注 "[此处有工具调用: xxx]"

### 6.3 多媒体内容处理

- 摘要时只提取文本内容
- 包含图片/文件的消息，在摘要中标注 "[此处有图片/文件]"
- 图片消息的 token 计算：按固定值估算（如 85 tokens/图片）或使用 OpenAI 的计算规则

### 6.4 消息不可拆分原则

- 保留消息时，以完整消息为最小单位
- 如果单条消息的 token 数超过 Retain 阈值，仍保留该完整消息
- 示例：Retain=2000，最后一条消息有 3000 tokens → 仍保留这条完整消息

**边界情况处理**：

1. **空消息或只有 system 消息**：不压缩，直接透传
2. **只有一条对话消息**：不压缩，直接透传（没有历史可压缩）
3. **所有对话消息都在保留范围内**：不压缩，直接透传（即使总 token 超过阈值）
4. **system 消息占用大量 token 导致总量超阈值，但对话消息都在保留范围内**：不压缩，直接透传
5. **tool 消息找不到对应的 assistant**：保持原分割点，记录警告日志
6. **摘要模型返回空内容或 Choices 为空**：视为生成失败，直接透传原始请求
7. **消息 Content 格式异常**：跳过该内容，继续处理其他消息

### 6.5 摘要模型选择逻辑

```
用户配置的模型（非空） → 使用用户配置的模型
    ↓ 为空
系统配置的模型（非空） → 使用系统配置的模型
    ↓ 为空
使用用户当前请求的模型（request.Model）
```

**说明**：当摘要模型配置为空时，使用用户当前请求的模型生成摘要，这样更符合用户预期，也避免了需要单独配置摘要模型的麻烦。

### 6.6 摘要生成失败处理

- 网络超时、模型不可用、余额不足等情况
- **处理方式**：直接透传原始请求，不阻断用户请求
- **日志记录**：
  - 失败情况记录到系统日志（WARN 级别），便于排查
  - 不记录到 compression_logs 表（该表只记录成功的压缩）
- 响应头 `X-Context-Compressed` 设置为 `false`

### 6.7 流式响应处理

- 压缩处理在请求发送前完成，不影响流式响应（stream=true）
- 响应头在流式响应开始时就会发送，包含压缩信息
- 流式模式下的压缩逻辑与非流式完全相同

---

## 7. 计费设计

### 7.1 计费策略

| 配置 | 行为 |
|------|------|
| ContextCompressionBillUser = true | 摘要生成的 token 消耗计入用户账户 |
| ContextCompressionBillUser = false | 摘要生成的 token 消耗由平台承担 |

### 7.2 计费记录

摘要生成的调用记录到 `compression_logs` 表（见第 11 章），包含：
- 原始 token 数、压缩后 token 数、摘要 token 消耗
- 摘要生成费用、是否计费给用户
- 用户 ID、令牌 ID、请求模型、摘要模型等信息

**注意**：摘要生成不记录到主 `logs` 表，避免与正常请求日志混淆。

---

## 8. 前端界面设计

### 8.1 管理员配置页面

位置：系统设置 → 运营设置 → 上下文压缩

```
┌─────────────────────────────────────────────────────────────┐
│ 上下文压缩设置                                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ [开关] 启用上下文压缩功能                                    │
│                                                             │
│ 触发阈值: [8000] tokens                                     │
│ 提示：当对话总 token 数超过此值时触发压缩                    │
│                                                             │
│ 保留 token 数: [2000] tokens                                │
│ 提示：保留最近消息的 token 数量，不参与压缩（不拆分消息）    │
│                                                             │
│ 摘要模型: [                    ]                            │
│ 提示：用于生成摘要的模型，留空表示使用当前请求的模型          │
│                                                             │
│ [开关] 向用户计费                                            │
│ 提示：摘要生成的 token 消耗是否计入用户账户                   │
│                                                             │
│ 系统提示词:                                                  │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ 请将以下对话历史压缩成一段简洁的摘要，保留关键信息：      │ │
│ │ 1. 用户的主要问题和需求                                  │ │
│ │ 2. 重要的决策和结论                                      │ │
│ │ ...                                                      │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ [保存设置]                                                   │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 用户个人设置页面

位置：个人中心 → 设置 → 上下文压缩

```
┌─────────────────────────────────────────────────────────────┐
│ 上下文压缩设置                                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 启用状态: [跟随系统 ▼]  (当前系统设置: 已启用)               │
│           - 跟随系统                                         │
│           - 启用                                             │
│           - 禁用                                             │
│                                                             │
│ 触发阈值: [    ] tokens  (留空使用系统默认: 8000)            │
│ 提示：当对话总 token 数超过此值时触发压缩                    │
│                                                             │
│ 保留 token 数: [    ] tokens  (留空使用系统默认: 2000)       │
│ 提示：保留最近消息的 token 数量（不拆分消息）                │
│                                                             │
│ 摘要模型: [                ] (留空使用当前请求的模型)        │
│ 提示：填写模型名称，留空表示使用当前请求的模型                │
│                                                             │
│ 系统默认提示词（只读）:                                      │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ 请将以下对话历史压缩成一段简洁的摘要，保留关键信息：      │ │
│ │ ...                                                      │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ 自定义补充提示词（可选）:                                    │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │                                                         │ │
│ │ [用户输入区域]                                           │ │
│ │                                                         │ │
│ └─────────────────────────────────────────────────────────┘ │
│ 提示：自定义内容会追加到系统提示词之后                       │
│                                                             │
│ [保存设置]                                                   │
└─────────────────────────────────────────────────────────────┘
```

### 8.3 用户压缩统计页面

位置：个人中心 → 压缩统计

```
┌─────────────────────────────────────────────────────────────┐
│ 上下文压缩统计                                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 统计概览                                                     │
│ ┌─────────────┬─────────────┬─────────────┬───────────────┐ │
│ │ 压缩次数    │ 节省 Token  │ 压缩率      │ 摘要费用      │ │
│ │ 156         │ 937,500     │ 75%         │ $0.045        │ │
│ └─────────────┴─────────────┴─────────────┴───────────────┘ │
│                                                             │
│ 时间范围: [最近7天 ▼]  [自定义...]                          │
│                                                             │
│ 压缩记录                                                     │
│ ┌───────────────────────────────────────────────────────────┐│
│ │ 时间        │ 原始Token │ 压缩后 │ 节省   │ 模型    │ 费用 ││
│ ├───────────────────────────────────────────────────────────┤│
│ │ 01-15 14:30 │ 8,500    │ 2,500  │ 6,000  │ gpt-4o  │ $0.00││
│ │ 01-15 14:25 │ 9,200    │ 2,800  │ 6,400  │ gpt-4o  │ $0.00││
│ │ ...                                                       ││
│ └───────────────────────────────────────────────────────────┘│
│                                                             │
│ [上一页] 第 1 页 / 共 8 页 [下一页]                          │
└─────────────────────────────────────────────────────────────┘
```

### 8.4 管理员压缩统计页面

位置：系统设置 → 运营设置 → 压缩统计

```
┌─────────────────────────────────────────────────────────────┐
│ 全局压缩统计                                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 全局概览                                                     │
│ ┌───────────┬───────────┬───────────┬───────────┬─────────┐ │
│ │ 压缩次数  │ 活跃用户  │ 节省Token │ 压缩率    │ 总费用  │ │
│ │ 15,600    │ 234       │ 93.75M    │ 75%       │ $4.50   │ │
│ └───────────┴───────────┴───────────┴───────────┴─────────┘ │
│                                                             │
│ 时间范围: [最近30天 ▼]  用户筛选: [全部用户 ▼]              │
│                                                             │
│ Top 用户（按节省 Token 排序）                                │
│ ┌───────────────────────────────────────────────────────────┐│
│ │ 排名 │ 用户名   │ 压缩次数 │ 节省 Token │ 占比          ││
│ ├───────────────────────────────────────────────────────────┤│
│ │ 1    │ user1    │ 500      │ 1,500,000  │ 1.6%          ││
│ │ 2    │ user2    │ 450      │ 1,200,000  │ 1.3%          ││
│ │ ...                                                       ││
│ └───────────────────────────────────────────────────────────┘│
│                                                             │
│ 日志管理                                                     │
│ [清理压缩日志...]  提示：清理指定时间之前的压缩记录          │
└─────────────────────────────────────────────────────────────┘
```

---

## 9. API 设计

### 9.1 获取用户设置

```
GET /api/user/settings
```

响应：
```json
{
  "success": true,
  "data": {
    "context_compression_enabled": 0,
    "context_compression_threshold": null,
    "context_compression_retain": null,
    "context_compression_model": "",
    "context_compression_prompt": "",
    "system_defaults": {
      "context_compression_enabled": true,
      "context_compression_threshold": 8000,
      "context_compression_retain": 2000,
      "context_compression_model": "",
      "context_compression_prompt": "请将以下对话历史..."
    }
  }
}
```

### 9.2 更新用户设置

```
PUT /api/user/settings
```

请求体：
```json
{
  "context_compression_enabled": 1,
  "context_compression_threshold": 6000,
  "context_compression_retain": 1500,
  "context_compression_model": "gpt-4o-mini",
  "context_compression_prompt": "请用中文生成摘要"
}
```

响应：
```json
{
  "success": true,
  "message": "设置已保存"
}
```

**参数校验**：
- `context_compression_enabled`: 0/1/2
- `context_compression_threshold`: 1000~128000，且必须 > retain（校验时使用有效值：用户设置值 > 系统默认值）
- `context_compression_retain`: 500~32000，且必须 < threshold（校验时使用有效值：用户设置值 > 系统默认值）
- `context_compression_model`: 非空时验证模型是否存在且用户有权限使用

**校验逻辑说明**：
- 当用户只设置 threshold 时，使用系统默认的 retain 值进行 threshold > retain 校验
- 当用户只设置 retain 时，使用系统默认的 threshold 值进行 threshold > retain 校验
- 当用户同时设置两者时，使用用户设置的值进行校验

**重置为系统默认**：
- 发送 `context_compression_enabled: 0` 重置启用状态为"跟随系统"
- 发送 `context_compression_threshold: null` 重置阈值为系统默认
- 发送 `context_compression_retain: null` 重置保留量为系统默认
- 发送 `context_compression_model: ""` 重置模型为使用当前请求的模型
- 发送 `context_compression_prompt: ""` 或 `null` 清除自定义提示词

**注意**：后端需要区分 JSON 中的 `null` 值和省略字段：
- `null` 值：明确表示重置为系统默认
- 省略字段：保持当前值不变（不更新该字段）
- 实现建议：使用指针类型（如 `*int`）来区分 null 和省略

### 9.3 获取压缩统计数据

```
GET /api/user/compression/stats
```

查询参数：
- `start_time`: 开始时间（Unix 时间戳，可选）
- `end_time`: 结束时间（Unix 时间戳，可选）
- `page`: 页码（默认 1）
- `per_page`: 每页数量（默认 20，最大 100）

响应：
```json
{
  "success": true,
  "data": {
    "summary": {
      "total_compressions": 156,
      "total_original_tokens": 1250000,
      "total_final_tokens": 312500,
      "total_summary_tokens": 45000,
      "tokens_saved": 937500,
      "compression_ratio": 0.75,
      "total_summary_cost": 0.045
    },
    "records": [
      {
        "id": 1001,
        "created_at": 1705312200,
        "original_tokens": 8500,
        "system_tokens": 200,
        "retained_tokens": 2000,
        "final_tokens": 2500,
        "summary_tokens": 650,
        "tokens_saved": 6000,
        "retained_messages": 5,
        "compressed_messages": 8,
        "request_model": "gpt-4o",
        "summary_model": "gpt-4o-mini",
        "summary_cost": 0.00035,
        "billed_to_user": true,
        "token_id": 123,
        "token_name": "my-token"
      }
    ],
    "pagination": {
      "page": 1,
      "per_page": 20,
      "total": 156,
      "total_pages": 8
    }
  }
}
```

**字段说明**：
- `original_tokens`: 压缩前总 token 数（所有消息）
- `system_tokens`: 原始 system 消息的 token 数（不参与压缩）
- `retained_tokens`: 保留的对话消息 token 数（不含 system）
- `final_tokens`: 压缩后发送给上游的 token 数（= system_tokens + 摘要输出 + retained_tokens）
- `summary_tokens`: 摘要生成消耗的 token 数（= summary_input_tokens + summary_output_tokens，用于计费）
- `tokens_saved`: 节省的 token 数 = original_tokens - final_tokens
- `compression_ratio`: 压缩率 = tokens_saved / original_tokens

### 9.4 管理员获取全局压缩统计

```
GET /api/admin/compression/stats
```

查询参数：
- `start_time`: 开始时间（Unix 时间戳，可选）
- `end_time`: 结束时间（Unix 时间戳，可选）
- `user_id`: 指定用户（可选）
- `top_n`: 返回 top_users 的数量（默认 10，最大 100）

响应：
```json
{
  "success": true,
  "data": {
    "summary": {
      "total_compressions": 15600,
      "total_users": 234,
      "total_original_tokens": 125000000,
      "total_final_tokens": 31250000,
      "total_summary_tokens": 4500000,
      "tokens_saved": 93750000,
      "compression_ratio": 0.75,
      "total_summary_cost": 4.5
    },
    "top_users": [
      {
        "user_id": 123,
        "username": "user1",
        "compression_count": 500,
        "tokens_saved": 1500000
      }
    ]
  }
}
```

### 9.5 清理压缩日志（管理员）

```
DELETE /api/admin/compression/logs?target_timestamp=xxx
```

查询参数：
- `target_timestamp`: 目标时间戳（Unix 时间戳），删除该时间之前的所有压缩日志

响应：
```json
{
  "success": true,
  "message": "",
  "data": 1234
}
```

说明：
- 与现有日志清理 API (`DELETE /api/log/`) 保持一致的设计
- `data` 返回被删除的记录数
- 前端复用现有的日志清理 UI 模式（选择时间 + 确认弹窗）

---

## 10. 响应头标识

当请求使用了上下文压缩时，在响应头中添加以下标识：

### 10.1 响应头字段

| 响应头 | 类型 | 说明 |
|--------|------|------|
| X-Context-Compressed | bool | 是否使用了压缩（"true" / "false"） |
| X-Original-Tokens | int | 压缩前总 token 数 |
| X-Final-Tokens | int | 压缩后发送给上游的 token 数 |
| X-Summary-Tokens | int | 摘要生成消耗的 token 数（= summary_input_tokens + summary_output_tokens） |
| X-Retained-Messages | int | 保留的对话消息数量 |

### 10.2 示例

```http
HTTP/1.1 200 OK
Content-Type: application/json
X-Context-Compressed: true
X-Original-Tokens: 8500
X-Final-Tokens: 2500
X-Summary-Tokens: 650
X-Retained-Messages: 5

{
  "id": "chatcmpl-xxx",
  "choices": [...]
}
```

### 10.3 客户端使用场景

客户端可以通过这些响应头：
- 了解本次请求是否触发了压缩
- 计算节省的 token 数量
- 监控压缩效果
- 调整自己的上下文管理策略

---

## 11. 数据库扩展：压缩记录表

为了支持统计功能，需要新建压缩记录表：

```sql
CREATE TABLE compression_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    username VARCHAR(255) NOT NULL DEFAULT '' COMMENT '用户名（冗余字段，便于查询）',
    token_id INT DEFAULT NULL COMMENT '使用的令牌ID',
    token_name VARCHAR(255) NOT NULL DEFAULT '' COMMENT '令牌名称（冗余字段，便于查询）',

    -- 压缩信息
    original_tokens INT NOT NULL COMMENT '压缩前总token数',
    system_tokens INT NOT NULL DEFAULT 0 COMMENT '原始system消息的token数',
    retained_tokens INT NOT NULL COMMENT '保留的对话消息token数',
    summary_input_tokens INT NOT NULL DEFAULT 0 COMMENT '摘要请求的输入token数',
    summary_output_tokens INT NOT NULL DEFAULT 0 COMMENT '摘要请求的输出token数',
    final_tokens INT NOT NULL COMMENT '压缩后发送给上游的总token数',
    retained_messages INT NOT NULL COMMENT '保留的对话消息数',
    compressed_messages INT NOT NULL COMMENT '被压缩的对话消息数',

    -- 模型信息
    request_model VARCHAR(255) NOT NULL COMMENT '用户请求的模型',
    summary_model VARCHAR(255) NOT NULL COMMENT '生成摘要的模型',

    -- 费用信息
    summary_cost DECIMAL(20, 6) DEFAULT 0 COMMENT '摘要生成费用',
    billed_to_user TINYINT(1) DEFAULT 1 COMMENT '是否计费给用户',

    created_at BIGINT NOT NULL COMMENT '创建时间（Unix时间戳）',

    INDEX idx_user_id (user_id),
    INDEX idx_username (username),
    INDEX idx_created_at (created_at),
    INDEX idx_user_created (user_id, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**字段说明**：
- `original_tokens`: 压缩前所有消息的 token 总数
- `system_tokens`: 原始 system 消息的 token 数（不参与压缩）
- `retained_tokens`: 保留的对话消息（不含 system）的 token 数
- `summary_input_tokens`: 摘要请求的输入 token 数（被压缩的消息转换为文本）
- `summary_output_tokens`: 摘要请求的输出 token 数（生成的摘要）
- `final_tokens`: 压缩后实际发送给上游的 token 数（= system_tokens + summary_output_tokens + retained_tokens）
- `tokens_saved` = `original_tokens` - `final_tokens`（节省的 token 数，API 返回时计算）
- `summary_tokens` = `summary_input_tokens` + `summary_output_tokens`（API 返回时计算）

**数值验证公式**：
- `original_tokens` = `system_tokens` + 被压缩消息的 token 数 + `retained_tokens`
- `final_tokens` = `system_tokens` + `summary_output_tokens` + `retained_tokens`

---

## 12. 实现步骤

### 第一阶段：基础设施

1. 创建 `user_settings` 表和对应的 Model
2. 创建 `compression_logs` 表和对应的 Model
3. 在 `options` 表添加系统级配置项
4. 实现配置的读取和合并逻辑
5. 集成 token 计算库（tiktoken 或类似）

### 第二阶段：后端 API

6. 实现用户设置的 CRUD API
7. 实现管理员配置的 API（复用现有 options API）
8. 实现压缩统计 API（用户端和管理员端）

### 第三阶段：核心功能

9. 在 Relay 层实现压缩逻辑
10. 实现摘要生成功能
11. 实现计费逻辑
12. 实现响应头标识
13. 实现压缩日志记录

### 第四阶段：前端界面

14. 管理员配置页面（8.1 节）
15. 用户个人设置页面（8.2 节）
16. 用户压缩统计页面（8.3 节）
17. 管理员压缩统计页面（8.4 节）

### 第五阶段：测试和优化

18. 单元测试
19. 集成测试（**重点测试以下场景确保不破坏现有功能**）：
    - 压缩功能禁用时，请求正常转发
    - 压缩功能启用但未触发时（token 数未超阈值），请求正常转发
    - 压缩功能触发但摘要生成失败时，原始请求正常转发
    - PassThrough 模式下，压缩功能不生效，请求正常透传
    - 流式响应（stream=true）正常工作
    - 多模态消息（图片、音频、视频）正常处理
    - Tool Calls 消息配对正确
20. 性能优化

---

## 13. 注意事项

### 13.1 性能考虑

- 摘要生成会增加请求延迟（额外的 API 调用）
- 建议使用快速便宜的模型（如 gpt-4o-mini、claude-3-haiku）
- Token 计算需要高效实现，避免成为性能瓶颈
- 压缩日志写入建议使用异步批量写入，避免影响请求响应时间
- 可考虑异步生成摘要并缓存（未来优化）
- **摘要生成超时**：建议设置 30 秒超时，超时后直接透传原始请求

### 13.2 安全考虑

- 用户填写的模型名称需要验证（检查模型是否存在且用户有权限使用）
- 防止用户通过自定义提示词注入恶意内容：
  - 用户自定义提示词仅作为补充追加到系统提示词之后
  - 不允许用户覆盖或修改系统默认提示词
  - 对用户输入进行基本的长度限制（建议最大 2000 字符）
  - 摘要生成使用独立的 API 调用，与用户原始请求隔离
- **递归风险防护**：摘要生成请求必须绕过压缩功能，避免递归调用。实现时应在摘要请求中添加内部标记或使用独立的调用路径
- **SQL 注入防护**：用户设置的 model 名称等字段在数据库查询时必须使用参数化查询
- **摘要模型选择**：建议使用可信的内部模型作为摘要模型，避免将用户对话内容发送到不可信的第三方服务
- **频率限制**：建议对压缩功能添加频率限制，防止用户故意触发大量压缩请求消耗资源

### 13.3 兼容性考虑

- 只对 ChatCompletions 请求生效
- 不影响其他类型的请求
- 失败时静默回退，不阻断用户请求
- 响应头标识不影响原有响应格式
- **PassThrough 模式**：当 `PassThroughRequestEnabled` 或 `PassThroughBodyEnabled` 启用时，压缩功能不生效，因为请求体会直接透传到上游，不经过消息处理
- **多 system 消息兼容性**：压缩后会在原 system 消息之后插入一条摘要 system 消息。大多数现代 LLM（OpenAI、Claude、Gemini 等）都支持多个 system 消息。如果目标模型不支持，可以考虑将摘要作为 user 消息插入，但这可能影响摘要的权重
- **渠道 SystemPrompt 兼容**：压缩功能与渠道的 `SystemPrompt` 设置兼容，压缩后的摘要消息会在渠道 SystemPrompt 处理之前插入

### 13.4 Token 计算准确性

- 不同模型的 tokenizer 可能不同
- 建议使用通用的 tiktoken（cl100k_base）作为估算基准
- 允许一定的误差范围

### 13.5 数据保留策略

- `compression_logs` 表数据量可能较大
- 与现有 `logs` 表保持一致，采用**手动清理**方式
- 管理员可在后台选择时间点，清理该时间之前的压缩日志
- 复用现有的日志清理 UI 模式

### 13.6 监控指标

建议监控以下指标：
- **压缩触发次数**：每分钟/小时触发压缩的请求数
- **平均压缩率**：`tokens_saved / original_tokens` 的平均值
- **摘要生成延迟**：摘要 API 调用的 P50/P95/P99 延迟
- **摘要生成失败率**：失败次数 / 总触发次数
- **节省的 token 总量**：累计节省的 token 数
- **摘要生成成本**：累计摘要生成费用

### 13.7 配置热更新

- 系统级配置（options 表）修改后应立即生效，无需重启服务
- 用户级配置（user_settings 表）修改后立即生效
- 建议在内存中缓存系统配置，定期刷新（如每分钟）或使用配置变更通知机制

### 13.8 并发处理

- 每个请求独立处理，无共享状态
- 压缩逻辑是无状态的，不存在并发冲突
- 压缩日志写入使用数据库事务保证一致性

### 13.9 日志规范

建议记录以下日志：

| 场景 | 日志级别 | 内容 |
|------|---------|------|
| 压缩成功 | INFO | 用户ID、原始token数、压缩后token数、耗时 |
| 摘要生成失败 | WARN | 用户ID、错误原因、是否回退 |
| 配置校验失败 | WARN | 用户ID、无效的配置项、错误原因 |
| 模型不可用 | WARN | 用户ID、请求的模型、回退到的模型 |

### 13.10 未来扩展考虑

以下功能可在后续版本中考虑添加：

1. **渠道/令牌级别控制**：某些渠道或令牌可能需要单独禁用压缩功能
2. **压缩失败日志**：当前设计只记录成功的压缩，失败情况仅记录到系统日志
3. **摘要缓存**：对于相同的对话历史，可以缓存摘要结果避免重复生成
4. **异步压缩**：对于非流式请求，可以考虑异步生成摘要以减少延迟
5. **压缩质量评估**：添加机制评估摘要质量，确保关键信息不丢失
6. **数据库迁移**：如果未来修改表结构，需要提供迁移脚本保证旧数据兼容

